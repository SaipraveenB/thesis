\chapter{Generative invariants}
\label{chapter-gen}

So far in this thesis, we have presented \sls~as a framework for
presenting transition systems. This view focuses on synthetic
transitions as a way of relating pairs of process states, either with
one transition $(\Psi; \Delta) \leadsto (\Psi'; \Delta')$ or with a
series of transitions $(\Psi; \Delta) \leadsto^* (\Psi';
\Delta')$. This chapter will focus on another view of concurrent
\sls~specifications as {\it grammars} for describing well-formed
process states. This view was presented previously in the discussions
of adequacy in Section~\ref{sec:framework-reggenworld} and in
Section~\ref{sec:nat-ssos-adequacy}.

The grammar-like specifications that describe well-formed process
states are called {\it generative signatures}, and generative
signatures can be used to specify sets of process states, or {\it
  worlds}. By the analogy with grammars, we could also describe worlds
as {\it languages} of process states recognized by the grammar. In our
previous discussions of adequacy in
Section~\ref{sec:framework-reggenworld} and in
Section~\ref{sec:nat-ssos-adequacy}, the relevant world was a set of
process states that we could put in bijective correspondence with the
states of an abstract machine.

Our primary use of generative specifications in this thesis is showing
that, under some generative signature $\Sigma_{\it Gen}$ that defines
a world $\mathcal W$, whenever $(\Psi; \Delta) \in \mathcal W$ and
$(\Psi; \Delta) \leadsto_\Sigma (\Psi'; \Delta')$ it is always the
case that $(\Psi'; \Delta') \in \mathcal W$.  (The signature $\Sigma$,
which allows the step to happen, is some other signature that describes
the transition system we are studying.)  In such a case, the
world or language of well-formed process states is called a
{\it generative invariant} of $\Sigma$.

\subsection*{Type preservation}

The purpose of this chapter is to demonstrate that generative
invariants are a reasonable way of talking about invariants of
\sls~specifications, especially well-formedness and well-typedness
invariants of substructural operational semantics specifications like
the ones presented in Part II. Well-formedness invariants are part adequacy
theorems, as we have already
seen. Well-typedness invariants are important because they allow us to
prove {\it language safety}, the property (discussed way back in the
introduction) that a language specification is completely free
from undefined behavior.

We don't generally expect all syntactically well-formed expressions
$\obj{e}$ to be free of undefined behavior. When we want to prove
language safety for a small-step SOS specification like $\obj{e
  \mapsto e'}$ from Section~\ref{sec:evaluationcontexts} and the
beginning of Chapter~\ref{chapter-absmachine}, we also define a
judgment $\obj{x_1{:}{\it tp_1},\ldots, x_n{:}{\it tp_n} \vdash e :
  {\it tp}}$.  This {\it typing judgment} expresses that $\obj{e}$ has
type $\obj{\it tp}$ if the expression variables $\obj{x_1, \ldots,
  x_n}$ are respectively assumed to have the types $\obj{\it tp_1,
  \ldots, tp_n}$. (Note that $\obj{\it tp}$ is an {\it object-level
  type} as described in Section~\ref{sec:gen-ordertp}, not an LF type
$\tau$ from Chapter~\ref{chapter-framework}.) Using the typing
judgment, we can prove the safety theorem -- all well-typed
expressions are free from undefined behavior -- by way of two
theorems. The first theorem is {\it preservation}: if $\obj{\cdot
  \vdash e : {\it tp}}$ and $\obj{e \mapsto e'}$ then $\obj{\cdot
  \vdash e' : {\it tp}}$. The second theorem is {\it progress}: if
$\obj{\cdot \vdash e : {\it tp}}$, then either there is some
$\obj{e'}$ such that $\obj{e \mapsto e'}$ or else $\obj{e}$ is already
a value.

In SSOS specifications, generative specifications are analogous to
typing judgments, and establishing a generative invariant is analogous
to proving a preservation theorem. Progress theorems for SSOS
specifications will be discussed in Chapter~\ref{chapter-safety}.
This argument forms the centerpiece of the third refinement of our
central thesis:

\smallskip
\begin{quote} 
  {\bf Thesis (Part III):} {\it The \sls~specification of the operational
    semantics of a programming language is a suitable basis for formal
    reasoning about properties of the specified language.}
\end{quote} 


\subsection*{Overview}

In Section~\ref{sec:gen-worlds} we review how generative signatures
define a world and show how the {\it regular worlds} that Sch\"urmann
implemented in Twelf \cite{schurmann00automating} fall out as a
special case of the worlds described by generative signatures.  We
will then discuss invariants of operationalized ordered abstract
machines, introduced in Section~\ref{sec:nat-ssos-adequacy}, more
generally (Section~\ref{sec:gen-order}). In
Section~\ref{sec:gen-ordertp} we will extend that discussion from
well-{\it formed} process states to well-{\it typed} process states.
This is not a large technical shift, but conceptually it is an
important step from thinking about adequacy-like properties to
thinking about preservation theorems. 

In Section~\ref{sec:gen-state}
we describe how generative invariants can be established for the sorts
of stateful signatures considered in
Section~\ref{sec:richer-ordered-abstract}. In
Section~\ref{sec:gen-destinations} we consider invariants for
specifications in the image of the destination-adding transformation
from Chapter~\ref{chapter-destinations}.  In
Section~\ref{sec:gen-letcc} we consider the peculiar case of
first-class continuations, which require us to use persistent
continuation frames as described in Section~\ref{sec:dest-continuations}. 
%Finally, in Section~\ref{sec:gen-count} we
%introduce a more complicated class of generative invariants that
%capture the numerical properties of specifications that appear in the
%\sls~encoding of voting and auction protocols.

\section{Worlds}
\label{sec:gen-worlds}

{\it Worlds} are nothing more or less than sets of process states
$(\Psi; \Delta)$ -- in the discussion here, we will specifically
exclude process states $(\Psi; \Delta)_{\lf\sigma}$ with a non-empty
accompanying substitution $\lf\sigma$.\footnote{These accompanying
  substitutions were presented in
  Section~\ref{sec:sls-processstates}.}

A world is described by the combination of an initial process state
and generative signature. We define a generative
signature as follows:

\bigskip
\begin{definition}\label{def:gensig}
  A {\em generative signature} is one where the ordered, mobile, and
  persistent atomic propositions can be separated into two sets -- the
  {\em terminals} and the {\em nonterminals}. Synthetic transitions
  enabled by a generative signature only consume (or reference) 
  terminals and LF terms, but their output variables can include
  LF variables, variables associated with terminals, and variables
  associated with nonterminals.
\end{definition}
\bigskip

\noindent
A generative signature describes a world with the help of the
restriction operator $\restrictsig{(\Psi; \Delta)}{\Sigma}$ introduced
in Section~\ref{sec:framework-restriction}. If $(\Psi; \Delta)$ is
well-defined under the generative signature $\Sigma_{\it Gen}$, and
$\Sigma$ is any signature that includes all of the generative
signature's terminals (and all of its LF bits) but none of its
nonterminals, then $\restrictsig{(\Psi; \Delta)}{\Sigma}$ is only
defined when the only remaining nonterminals in $\Delta$ are
persistent and can therefore be filtered out of $\Delta$. (As long as
$\Sigma_{\it Gen}$ and $\Sigma$ have the same LF declarations, the LF
context $\Psi$ won't have anything filtered out.) When the
classification of terminals and nonterminals is clear, we will leave
off the restricting signature and just write $\restrictsig{(\Psi;
  \Delta)}{}$.

Definition~\ref{def:gensig} is intentionally quite broad -- it need
not even be decidable whether a process state belongs to a particular
world.\footnote{Proof: consider the initial state
  $(x{:}\istrue{\susp{\sf gen}})$ and the rule $\forall
  \lf{e}.\,\forall\lf{v}.\,{\sf gen} \fuse {!}({\sf
    ev}\,\lf{e}\,\lf{v}) \lefti \{ {\sf terminating}\,\lf{e} \}$. The
  predicate ${\sf gen}$ is a nonterminal, the predicate ${\sf
    terminating}$ is a terminal, and ${\sf ev}$ is the encoding of
  big-step evaluation $\obj{e \Downarrow v}$ from
  Figure~\ref{fig:example-transform-cbv}.  The language described is
  isomorphic to the set of $\lambda$-calculus expressions that terminate
  under a call-by-value strategy,
  and membership in that set is undecidable.} Future tractable
analyses will therefore presumably be based upon further restrictions
of the very general Definition~\ref{def:gensig}.  Context-free
grammars are one obvious specialization of generative signatures; we
used this correspondence as an intuitive guide in
Section~\ref{sec:framework-reggenworld}.  Perhaps less obviously,
the regular worlds of Twelf \cite{schurmann00automating} are another
specialization of generative signatures.


\subsection{Regular worlds}
\label{sec:gen-regularworlds}

The
regular world specifications used in Twelf
\cite{schurmann00automating} are made up of {\it blocks}. A block
describes a little piece of an LF context, and is declared in the LF
signature as follows:
\[
 {\sf blockname} :
 {\sf some}~\{\lf{a_1}{:}\tau_1\}\ldots\{\lf{a_n}{:}\tau_n\}
~{\sf block}~\{\lf{b_1}{:}\tau'_1\}\ldots\{\lf{b_m}{:}\tau'_m\}
\]
A block declaration is well formed in the signature $\Sigma$ if 
$\left(\lf{a_1}{:}\tau_1,\ldots,\lf{a_{i-1}}{:} \tau_{i-1} \right)\vdash_\Sigma
\tau_i \,{\sf type}$ for $1 \leq i \leq n$ and if 
$\left(\lf{a_1}{:}\tau_1,\ldots,\lf{a_{n}}{:} \tau_{n},
 \lf{b_1}{:}\tau'_1,\ldots,\lf{b_{j-1}}{:}\tau'_{j-1}\right) \vdash_\Sigma
\tau_j \,{\sf type}$ for $1 \leq j \leq m$. 

The first list of LF variable bindings
$\{\lf{a_1}{:}\tau_1\}\ldots\{\lf{a_n}{:}\tau_n\}$ that 
come after the ${\sf some}$ keyword describe the types
of concrete LF terms that must exist for the block to be well formed.
The second list of LF variable bindings represents the bindings that
the block actually adds to the LF context. The regular worlds of 
Twelf are defined as sets of block identifiers 
$({\sf block1} \mid \ldots \mid {\sf blockn})$. A set of block identifiers
and a Twelf signature $\Sigma$ define a world as follows: if
\smallskip
\begin{itemize}
\item $\Psi$ is a well-formed
LF context in the current world, 
\item ${\sf blockname} :
 {\sf some}~\{\lf{a_1}{:}\tau_1\}\ldots\{\lf{a_n}{:}\tau_n\}
~{\sf block}~\{\lf{b_1}{:}\tau'_1\}\ldots\{\lf{b_m}{:}\tau'_m\} \in \Sigma$
 is one of the blocks in the current world, and
\item there is a $\lf{\sigma}$ such that
$\Psi \vdash_\Sigma \lf{\sigma} :
\lf{a_1}{:}\tau_1,\ldots,\lf{a_n}{:}\tau_n$, 
\end{itemize}
\smallskip then $\Psi, \lf{b_1}{:}\lf\sigma\tau'_1,\ldots,
\lf{b_m}{:}\lf\sigma\tau'_m$ is also a well-formed LF context in the
current world. The {\it closed world}, which contains only the empty
process state, is a subset of every regular world, so this definition
gives us the rules for generating a world -- a set of contexts -- from
a series of block declarations.

One simple example of a regular world (previously discussed in
Section~\ref{sec:framework-reggenworld}) is the world that just
contains arbitrary expression variables with LF type ${\sf exp}$. This
world can be described with the block ${\sf blockexp}$:
\[
 {\sf blockexp} : 
 {\sf some}
~{\sf block}~\{{\lf x}{:}{\sf exp}\}
\]
If we had a judgment ${\sf natvar}\,\lf{x}\,\lf{n}$ that associated
every LF variable $\lf{x}{:}{\sf exp}$ with some natural number
$\lf{n}{:}{\sf nat}$, then in order to make sure that every expression
variable was associated with some natural number we would use the world
described by this block:
\[
 {\sf blocknatvar} : 
 {\sf some}~\{{\lf n}{:}{\sf nat}\}
~{\sf block}~\{{\lf x}{:}{\sf exp}\}~
               \{\lf{\it nv}{:}{\sf natvar}\,\lf{x}\,\lf{n}\}
\]
The world described by the combination of ${\sf blockexp}$ and ${\sf
  blocknatvar}$ is one where every LF variable $\lf{x}{:}{\sf exp}$
is associated with either zero or one LF variables of type ${\sf
  natvar}\,\lf{x}\,\lf{n}$. Assuming that there are no constants of
type ${\sf natvar}$, a property we can easily enforce with subordination, this
gives us a uniqueness property: if ${\sf natvar}\,\lf{x}\,\lf{n}$ and
${\sf natvar}\,\lf{x}\,\lf{m}$, then $\lf{m} = \lf{n}$. 

\subsection{Regular worlds from generative signatures}

A block declaration ${\sf blockname} :
 {\sf some}~\{\lf{a_1}{:}\tau_1\}\ldots\{\lf{a_n}{:}\tau_n\}
~{\sf block}~\{\lf{b_1}{:}\tau'_1\}\ldots\{\lf{b_m}{:}\tau'_m\}$ can
be described by one rule in a generative signature:
\begin{align*}
&{\sf blockname} : 
  \forall \lf{a_1}{:}\tau_1\ldots \forall\lf{a_n}{:}\tau_n.\,
  \{ \exists \lf{b_1}{:}\tau'_1 \ldots \lf{b_m}{:}\tau'_m.\,
     \one
  \}
\intertext{Because a regular world is just a set of blocks, 
the generative signature corresponding
to a regular world contains one rule for each block in the regular
worlds description.
The world $({\sf blockexp} \mid {\sf blockvar})$ corresponds
to the following generative signature:}
&{\sf nat} : {\sf type}, 
\\
&\mbox{\it \ldots declare constants of type ${\sf nat}$ \ldots }
\\
&{\sf exp} : {\sf type}, 
\\
&\mbox{\it \ldots declare constants of type ${\sf exp}$ \ldots }
\\
&{\sf blockexp} : 
  \{ \exists \lf{x}{:}{\sf exp}.\,\one\},
\\
&{\sf blocknatvar} : \forall \lf{n}{:}{\sf nat}.\,
  \{ \exists \lf{x}{:}{\sf exp}.\,
     \exists \lf{\it nv}{:}{\sf natvar}\,\lf{x}\,\lf{n}.\, \one \}
\end{align*}
Call this regular world signature $\Sigma_{\it RW}$. It is an extremely
simple example of a generative signature -- there are no
terminals and no nonterminals -- so the restriction operator has
no effect. The world described by $({\sf blockexp} \mid {\sf blocknatvar})$
is identical to the set of LF contexts $\Psi$ such that
$(\cdot; \cdot) \leadsto_{\Sigma_{RW}} (\Psi; \cdot)$.

\subsection{Regular worlds in substructural specifications}

From the structure of translated LF regular worlds, it is hopefully
apparent that by replacing the proposition $\one$ in the heads of the
generative ${\sf block*}$ rules with more interesting positive
\sls~propositions,  we can extend the language of regular
worlds to allow the introduction of ordered, mobile, and persistent
\sls~propositions as well. For instance, the rule
${\sf blockitem} : 
\forall \lf{n}. \, \{ {\sf item}\,\lf{n} \}$,
where ${\sf item}$ is a mobile predicate,
describes the world of contexts that take the form
$\left(\cdot; ~ x_1{:}\iseph{\susp{{\sf item}\,\lf{n_1}}}, ~
         \ldots, ~
         x_k{:}\iseph{\susp{{\sf item}\,\lf{n_k}}}\right)$
for some numbers $\lf{n_1}\ldots\lf{n_k}$. 
The world described by this generative signature is an invariant of a
rule like
\begin{align*}
  {\sf merge} : 
  \forall \lf{n}.\,\forall\lf{m}.\,\forall\lf{p}.\,
   {\sf item}\,\lf{n} \fuse
   {\sf item}\,\lf{m} \fuse
   {!}({\sf plus}\,\lf{n}\,\lf{m}\,\lf{p}) 
    \lefti \{ {\sf item}\,\lf{p} \}
\end{align*}
that combines two items,
where ${\sf plus}$ is  negative predicate defined with a deductive
specification as in
Figure~\ref{fig:plus}.  

Such substructural generalizations of regular worlds are sufficient
for the encoding of stores in Linear LF \cite{cervesato02linear} and
stacks in Ordered LF \cite{polakow01ordered}. They also suffice
to describe well-formedness invariants in Felty and Momigliano's
sequential specifications \cite{felty12hybrid}. However, regular
worlds are insufficient for the
invariants discussed in the remainder of this chapter.

\subsection{Generative versus consumptive signatures}

The example of regular worlds helps explain why generative signatures are
{\it generative}. A earlier version of the results in this chapter and
the next used {\it consumptive} signatures
\cite{simmons10type}. Consumptive signatures are generative
signatures with the arrows turned around: we consume well-formed
contexts using consumptive rules like $\forall\lf{e}.\,{\sf
  eval}\,\lf{e} \lefti \{ {\sf gen} \}$ and $\forall \lf{f}.\,{\sf
  gen} \fuse {\sf cont}\,\lf{f} \lefti \{ {\sf gen} \}$ instead of
using generative 
rules like $\forall\lf{e}.\,{\sf gen}\lefti \{ {\sf eval}\,\lf{e} \}$
and $\forall \lf{f}.\,{\sf gen} \lefti \{ {\sf gen} \fuse {\sf
  cont}\,\lf{f} \}$. 

One arugable advantage of consumptive signatures is that it lets us
work with complete derivations, rather than traces. That is, using a
consumptive signature, we can talk about the set of process states
$(\Psi; \Delta)$ where $\Psi; \Delta \vdash \islax{{\sf gen}}$ rather
than the set of process states where $(\cdot; x{:}\istrue{\susp{\sf
    gen}}) \leadsto^* (\Psi; \Delta)$.\footnote{As long as $\Psi$ and
  $\Delta$ contain only nonterminals -- using consumptive signatures
  doesn't obviate the need for the restriction operation
  $\restrictsig{(\Psi; \Delta)}{}$ or some equivalent restriction
  operation.} For purely context-free-grammar-like invariants, such as
the PDA invariant from Section~\ref{sec:framework-reggenworld} and the
SSOS invariant from Section~\ref{sec:nat-ssos-adequacy}, generative
and consumptive signatures are effectively equivalent.

However, for generative signatures describing regular worlds, there is
no notion of turning the arrows around to get an appropriate
consumptive signature. In particular, say
we want to treat 
\begin{align*}
\Psi_{\it good} & = 
 \left(
 \lf{x_1}{:}{\sf exp}, \lf{{\it nv}_1}{:}{\sf natvar}\,\lf{x_1}\,\lf{n_1},
 \lf{x_2}{:}{\sf exp}, \lf{{\it nv}_2}{:}{\sf natvar}\,\lf{x_2}\,\lf{n_2}
 \right)
\intertext{as a well-formed LF context but {\it not} treat }
\Psi_{\it bad} & = 
 \left(
 \lf{x}{:}{\sf exp}, \lf{{\it nv}_1}{:}{\sf natvar}\,\lf{x}\,\lf{n_1},
  \lf{{\it nv}_2}{:}{\sf natvar}\,\lf{x}\,\lf{n_2}
 \right)
\end{align*} as well-formed. It is trivial to use Twelf's regular
worlds or generative signatures to impose this condition, but it does
not seem possible to use consumptive signatures for this
purpose. There exists a substitution \mbox{$\lf{(x/\!\!/x_1, {\it
      nv}_1/\!\!/{\it nv}_1, x/\!\!/x_2, {\it nv}_2/\!\!/{\it
      nv}_2)}$} from $\Psi_{\it good}$ to $\Psi_{\it bad}$; therefore,
by variable substitution (Theorem~\ref{thm:varsubst}), if there exists
a derivation of $\Psi_{\it good} \vdash_\Sigma \islax{\sf gen}$ there
also exists a derivation of $\Psi_{\it bad} \vdash_\Sigma \islax{\sf
  gen}$. 
%This means that consumptive signatures as presented in
%\cite{simmons10type} cannot describe the (regular) world that includes
%$\Psi_{\it good}$ and rejects $\Psi_{\it bad}$. 
This is related to the
issues of variable and pointer equality discussed in
Section~\ref{sec:mutable-storage}.

The generative signatures used to describe state in
Section~\ref{sec:gen-state} and destination-passing style in
Section~\ref{sec:gen-destinations} rely critically on the
regular-worlds-like uniqueness invariants that are provided by
generative signatures and not by consumptive signatures. (The progress
and preservation proofs in \cite{simmons10type} consider neither
mutable state nor destination-passing style.)

\section{Invariants of ordered specifications}
\label{sec:gen-order}

We already introduced generative invariants for ordered
abstract machine SSOS specifications in
Section~\ref{sec:nat-ssos-adequacy}. In this section, we will extend 
that generative invariant to ordered abstract machines
with parallel evaluation and recoverable failure.


\begin{figure}[t]
\fvset{fontsize=\small,boxwidth=229pt}
\VerbatimInput{sls/gen-order-prog.sls}
\caption{Ordered abstract machine with parallel evaluation and failure}
\label{fig:gen-order-prog}
\end{figure}

In Figure~\ref{fig:gen-order-prog} we describe a flat ordered abstract
machine with parallel features (parallel evaluation of the function
and argument in an application, as discussed in
Section~\ref{sec:trans-par} and Figure~\ref{fig:cbv-ev-ssos-par}) and
recoverable failure (as presented in Section~\ref{sec:failure} and
Figure~\ref{fig:ssos-fail}). To make sure there is still an
interesting sequential feature, we also introduce a let-expression
$\interp{{\sf let}\,x = e\,{\sf in}\,e'} = \lf{{\sf
    let}\,\interp{e}\,\lambda x.\interp{e'}}$. The particular features
are less important than the general setup, which effectively
represents all the specifications from
Chapter~\ref{chapter-absmachine} that used only ordered atomic
propositions.


Our goal is to describe a generative signature that represents the
well-formed process states of the specification in
Figure~\ref{fig:gen-order-prog}. What determines whether a process
state is well formed? The intended adequacy theorem was our guide in
Section~\ref{sec:nat-ssos-adequacy}, and the intended progress theorem
will guide our hand in Section~\ref{sec:gen-ordertp}. In this case,
our goal is that every well-formed state should be {\it
  reachable}. That is, if $(x{:}\istrue{\susp{\sf gen}})
\leadsto^* \Delta$ under the generative signature and if $\Delta$ contains no
instances of ${\sf gen}$, then there should be an expression $\obj{e}$
such that $(x{:}\istrue{\susp{{\sf eval}\,\interp{e}}}) \leadsto^*
\Delta$ under the signature from
Figure~\ref{fig:gen-order-prog}. (Because ${\sf gen}$ is the only
nonterminal, we can express that $\Delta$ contains no instances of
${\sf gen}$ with the restriction operator, writing
$\restrictsig{\Delta}{}$.) We will discuss the proof of this property
in Section~\ref{sec:well-formed-reachable}.

The analogues of the unary grammar productions, associated with the
terminals ${\sf eval}\,\lf{e}$, ${\sf retn}\,\lf{v}$, and ${\sf
  error}$, are straightforward:
%
\smallskip
\fvset{fontsize=\small,boxwidth=229pt}
\VerbatimInput{sls/gen-order-core.sls} 
\smallskip 
%
As in Section~\ref{sec:nat-ssos-adequacy}, we use a
deductively-defined judgment ${\sf value}\,\lf{v}$ to stipulate that
we only return values. The process state $(y{:}\istrue{\susp{{\sf
      retn}\,\interp{e_1\,e_2}}})$ is not well formed: the
application expression $\obj{e_1\,e_2}$ is not a value, and
there is no $\obj{e}$ such that $(x{:}\istrue{\susp{{\sf
      eval}\,\interp{e}}}) \leadsto^* (y{:}\istrue{\susp{{\sf
      retn}\,\interp{e_1\,e_2}}})$ under the signature from
Figure~\ref{fig:gen-order-prog}.

There is a potential catch when we consider the rules for sequential
continuations ${\sf cont}\,\lf{f}$ and parallel continuations ${\sf
  cont2}\,\lf{f}$. We expect a sequential continuation frame to be
preceded by a single well-formed computation, and for a parallel
continuation frame to be preceded by {\it two} well-formed
computations, suggesting these rules:
%
\smallskip
\fvset{fontsize=\small,boxwidth=229pt}
\VerbatimInput{sls/gen-order-bad.sls} 
\smallskip 
%
Even though ${\sf gen/cont}$ is exactly the rule for sequential
continuations in Section~\ref{sec:nat-ssos-adequacy}, this approach
conflicts with our guiding principle of reachability.
Both parallel and sequential continuations are indexed by
frames, but the parallel frame ${\sf app1}$ cannot appear in a
sequential continuation, nor can the sequential frame $({\sf
  let1}\,\lf{\lambda x.e\,x})$ appear in a parallel frame. 

\begin{figure}[tp]
\fvset{fontsize=\small,boxwidth=229pt}
\VerbatimInput{sls/gen-order.sls} 
\caption{Generative invariant: well-formed process states}
\label{fig:gen-order} 
\end{figure}

\newcommand{\siggenorder}{\Sigma_{\it Gen\ref{fig:gen-order}}}
\newcommand{\siggenordertp}{\Sigma_{\it Gen\ref{fig:gen-ordertp}}}
\newcommand{\siggenstate}{\Sigma_{\it Gen\ref{fig:gen-state}}}
\newcommand{\siggendests}{\Sigma_{\it Gen\ref{fig:gen-destinations}}}

This is fundamentally no more complicated than the restrictions we
placed on the ${\sf retn}\,\lf{v}$ terminal. All expressions (LF
variables of type ${\sf exp}$) can appear in ${\sf exp}\,\lf{e}$
propositions (and in ${\sf handle}\,\lf{e}$ propositions), but only
some can appear in ${\sf retn}\,\lf{v}$ frames. We describe that
subset of frames with the negative atomic proposition ${\sf
  value}\,\lf{v}$, which is deductively defined. Similarly, only some
frames can appear in ${\sf cont}\,\lf{f}$ terminals, and only some
frames can appear in ${\sf cont2}\,\lf{f}$ terminals. The former subset
can be expressed by a negative atomic proposition ${\sf okf}\,\lf{f}$,
and the latter by a negative atomic proposition ${\sf okf2}\,\lf{f}$.
Both of these are deductively defined.  The full specification of this
generative invariant is shown in Figure~\ref{fig:gen-order}; we will
refer to this generative signature as $\siggenorder$

\subsection{Inversion}\label{sec:inversion-genorder}

Traditional inversion lemmas are a critical part of preservation
properties for small-step operational semantics specifications. In 
traditional preservation theorems, we are often start with a derivation of
$\obj{e_1\,e_2 \mapsto e_1'\,e_2}$ and another derivation of
$\obj{\cdot \vdash e_1\,e_2 : {\it tp}}$. An inversion lemma then proceeds
by case analysis on the structure of the derivation 
$\obj{\cdot \vdash e : {\it tp}}$, and allows us to conclude that
$\obj{\cdot \vdash e_1 : {\it tp'} \Rightarrow {\it tp}}$
and that $\obj{\cdot \vdash e_2 : {\it tp'} }$ for some object-level
type $\obj{\it tp'}$.  In other words, an inversion lemma allows us to 
take knowledge about a term's structure and obtain information about 
the typing derivation's structure. 

Inversion on a generative signature is intuitively similar: we take
information about the structure of a process state and use it to learn
about the generative trace that formed that process state. Concurrent
equality (Section~\ref{sec:framework-concurrenteq}) is critical.
None the parts of the lemma below would hold if we did not
equate traces such as such as
\[
\trstep{x_1, x_2, x_3}{{\sf gen/cont2}\,\lf{f}\,(x' \fuse {\sf okf2/app1})}; ~
\trstep{y_1}{{\sf gen/eval}\,\lf{e_1}\,x_1}; ~
\trstep{y_2}{{\sf gen/eval}\,\lf{e_2}\,x_2}
\]and\[
\trstep{x_1, x_2, x_3}{{\sf gen/cont2}\,\lf{f}\,(x' \fuse {\sf okf2/app1})}; ~
\trstep{y_2}{{\sf gen/eval}\,\lf{e_2}\,x_2}; ~
\trstep{y_1}{{\sf gen/eval}\,\lf{e_1}\,x_1}
\]
by concurrent equality.

\bigskip
\begin{lemma}[Inversion -- Figure~\ref{fig:gen-order}]~
\begin{enumerate}
\item If 
   $T :: (x{:}\istrue{\susp{\sf gen}}) \leadsto^*_{\siggenorder}
         \tackon{\Theta}{y{:}\istrue{\susp{{\sf eval}\,\lf{e}}}}$,
\\ then 
   $T = \left(T'; \trstep{y}{{\sf gen/eval}\,\lf{e}\,x'}\right)$.
\medskip
\item If 
   $T :: (x{:}\istrue{\susp{\sf gen}}) \leadsto^*_{\siggenorder}
         \tackon{\Theta}{y{:}\istrue{\susp{{\sf retn}\,\lf{v}}}}$,
\\ then 
   $T = \left(T'; \trstep{y}{{\sf gen/retn}\,\lf{v}\,(\tfuser{x'}{\tbangr{N}})}\right)$,
\\ where 
   $\cdot \vdash_{\siggenorder} N : {{{\sf value}\,\lf{v}}}$.
\medskip
\item If 
   $T :: (x{:}\istrue{\susp{\sf gen}}) \leadsto^*_{\siggenorder}
         \tackon{\Theta}{y_1{:}\istrue{\susp{{\sf gen}}}, ~
                         y_2{:}\istrue{\susp{{\sf cont}\,\lf{f}}}}$,
\\ then 
   $T = \left(T'; \trstep{y_1,y_2}{{\sf gen/cont}\,\lf{f}\,(\tfuser{x'}{\tbangr{N}})}\right)$,
\\ where 
   $\cdot \vdash_{\siggenorder} N : {{{\sf okf}\,\lf{f}}}$.
\medskip
\item If
   $T :: (x{:}\istrue{\susp{\sf gen}}) \leadsto^*_{\siggenorder}
         \tackon{\Theta}{y_1{:}\istrue{\susp{{\sf gen}}}, ~
                         y_2{:}\istrue{\susp{{\sf gen}}}, ~
                         y_3{:}\istrue{\susp{{\sf cont2}\,\lf{f}}}}$,
\\ then 
   $T = \left(T'; \trstep{y_1,y_2,y_3}{{\sf gen/cont2}\,\lf{f}\,(\tfuser{x'}{\tbangr{N}})}\right)$,
\\ where 
   $\cdot \vdash_{\siggenorder} N : {{{\sf okf2}\,\lf{f}}}$.
\medskip
\item If 
   $T :: (x{:}\istrue{\susp{\sf gen}}) \leadsto^*_{\siggenorder}
         \tackon{\Theta}{y{:}\istrue{\susp{{\sf error}}}}$,
\\ then 
   $T = \left(T'; \trstep{y}{{\sf gen/error}\,x'}\right)$.
\medskip
\item If 
   $T :: (x{:}\istrue{\susp{\sf gen}}) \leadsto^*_{\siggenorder}
         \tackon{\Theta}{y_1{:}\istrue{\susp{{\sf gen}}}, ~
                         y_2{:}\istrue{\susp{{\sf handle}\,\lf{e}}}}$,
\\ then 
   $T = \left(T'; \trstep{y_1,y_2}{{\sf gen/handle}\,\lf{e}\,(\tfuser{x'}{\tbangr{N}})}\right)$.
\medskip
\end{enumerate}
In each instance above, 
$T' :: (x{:}\istrue{\susp{\sf gen}}) \leadsto^*_{\siggenorder}
          \tackon{\Theta}{x'{:}\istrue{\susp{{\sf gen}}}}$,
where the variables $x$ and $x'$ may or may not
be the same. (They are the same iff $T' = \emptytrace$.)
\end{lemma}

\begin{proof}
  Each case follows by induction and case analysis on the last steps
  of $T$.  In each case, we know that the trace cannot be empty,
  because the variable bindings $y{:}\istrue{\susp{{\sf
        eval}\,\lf{e}}}$, $y{:}\istrue{\susp{{\sf retn}\,\lf{v}}}$,
  $y_2{:}\istrue{\susp{{\sf cont}\,\lf{f}}}$,
  $y_3{:}\istrue{\susp{{\sf cont2}\,f}}$, $y{:}\istrue{\susp{{\sf
        error}}}$, and $y_2{:}\istrue{\susp{{\sf handle}\,\lf{e}}}$,
  respectively, appear in the final process state but not the initial
  process state. Therefore, $T =
  T''; S$ for some $T''$ and $S$.  Let ${\it Var}$ be the set of relevant
  variables -- $\{y\}$ in parts 1, 2, and 5, $\{y_1, y_2\}$ in parts 3
  and 6, and $\{y_1,y_2,y_3\}$ in part 4. 

  One possibility is that $\emptyset = S^{\bullet} \cap {\it Var}$. If so, it
  is always the case that $\emptyset = {^{\bullet}S} \cap {\it Var}$ as well,
  because ${\it Var}$ contains no persistent atomic propositions or LF
  variables. By the induction hypothesis we then get that $T'' = T''';
  S'$, where $S' = \trstep{y}{{\sf gen/eval}\,\lf{e}\,x'}$ in part 1,
  $S' = \trstep{y}{{\sf gen/retn}\,\lf{v}\,(\tfuser{x'}{\tbangr{N}})}$
  in part 2, and so on.  In each of the six parts, of course
  $S'{^\bullet} = {\it Var}$, so $\emptyset = S'{^\bullet} \cap {^\bullet}S$
  and $\left(T'''; S'; S\right) = \left(T'''; S; S'\right)$, so we can
  conclude letting $T' = \left(T''; S\right)$.

  If $S^{\bullet} \cap {\it Var}$ is nonempty, we must show by case
  analysis that $S^{\bullet} = {\it Var}$ and that furthermore $S$ is
  the step we were looking for. This is easy in cases 1, 2, and 5
  where ${\it Var}$ is a singleton set: there is only one rule that
  can produce an atomic proposition of type ${\sf gen}\,\lf{e}$, ${\sf
    retn}\,\lf{v}$, or ${\sf error}$, respectively.  In case 3, we
  observe that, if the variable bindings $y_1{:}\istrue{\susp{{\sf
        gen}}}$ and $y_2{:}\istrue{\susp{{\sf cont}\,\lf{f}}}$ appear
  in order in the substructural context, there is no step in the
  signature $\siggenorder$ that has $y_1$ among its output variables
  that does not also have $y_2$ among its output variables, and vice
  versa. The rule ${\sf gen/cont2}$ cannot be used to generate $y_1$,
  for instance, because it would have to also place either another
  ${\sf gen}$ proposition or a ${\sf cont2}\,{\lf f}$ proposition to
  the right of $y_1$, and we know that a ${\sf cont}\,{\lf f}$
  proposition actually appears in this position. Cases 4 and 6 work
  by similar reasoning.
\end{proof}

The critical step of inversion can be intuitively connected with the
idea that the grammar described by a generative signature is {\it
  unambiguous}. This will not hold in general. If there was
a rule ${\sf gen/redundant} : {\sf gen} \lefti \{ {\sf gen} \}$ in
$\Sigma_{\it Gen\ref{fig:gen-order}}$, for instance, then the final
step $S$ could be
$\trstep{y_1}{{\sf gen/redundant}\,y'}$, and this would invalidate our
inversion proof
for parts 3, 4, and 6, as $S^{\bullet}$ would be $\{y_1\}$, a strict
subset of the set $V$. 
% If we added a rule ${\sf gen/contback} :
% \forall{\lf f}.\,{\sf gen} \fuse {!}{\sf okf}\,\lf{f} \lefti \{ {\sf
%   cont}\,\lf{f} \fuse {\sf gen} \}$, where the conclusions are in the
% wrong order, then a trace $(x{:}\istrue{\susp{\sf gen}})
% \leadsto^*_{\siggenorder} \tackon{\Theta}{y{:}\istrue{\susp{{\sf
%         gen}}}}$
Conversely, if we tried to prove an inversion
property about traces $(x{:}\istrue{\susp{\sf gen}})
\leadsto^*_{\siggenorder} \tackon{\Theta}{y{:}\istrue{\susp{{\sf
        gen}}}}$, this property would again fail, because $V = \{ y
\}$ and in the case where the last step $S$ is driven by one of the
rules ${\sf gen/cont}$, ${\sf gen/cont2}$, or ${\sf gen/handle}$
$S^{\bullet}$ will be a strict superset of $V$.

The proof above could also be stated in form of case analysis on the
form of the last step and induction. The reason for {\it not} doing
that is more an issue of proof engineering: such a proof would require
enumerating 7 cases for each of the 6 inversion lemmas, leading to
proof whose size is in $O(n^2)$ where $n$ is the number of rules
in the generative signature. In this chapter, we will emphasize the principles
by which we can use to reason {\it concisely} about the specifications
we are interested in.

\subsection{Preservation}

\begin{theorem}[$\siggenorder$ is a generative invariant]\label{thm:siggenorder}
If $T_1 :: (x{:}\istrue{\susp{\sf gen}}) \leadsto^*_{\siggenorder} 
   \Delta$ and $S :: \restrictsig{\Delta}{} \leadsto \Delta'$
under the signature from Figure~\ref{fig:gen-order-prog}, then
$T_2 :: (x{:}\istrue{\susp{\sf gen}}) \leadsto^*_{\siggenorder} 
   \Delta'$
\end{theorem}

\begin{proof} As in the proofs of Theorem~\ref{thm:pda-preservation}
  and Theorem~\ref{thm:adequate-pres}, we enumerate the synthetic
  transitions possible under the signature in
  Figure~\ref{fig:gen-order-prog}, perform inversion on the structure
  of $T_1$, and then use the results of inversion to construct
  $T_2$. We give three illustrative cases corresponding to the
  fragment dealing with functions and parallel application.

\begin{description}
%%%%%%%%
%%%%%%%%
%%%%%%%%
\item 
  [Case $\trstep{y}{{\sf ev/lam}\,\lf{(\lambda x. e)}\,x}
   ::
   \tackon{\Theta}
     {x{:}\istrue{\susp{{\sf eval}\,\lf{({\sf lam}\,\lambda x.e)}}}}
   \leadsto
   \tackon{\Theta}
     {y{:}\istrue{\susp{{\sf retn}\,\lf{({\sf lam}\,\lambda x.e)}}}}$]~

\medskip
Applying inversion (Part 1) to $T_1$, we have 

\begin{tabbing}
$T_1 = ~$ \= \qquad \= $(x{:}\istrue{\susp{\sf gen}})$
\\
\>$T'$
\\
\>\>$\tackon{\Theta}{x'{:}\istrue{\susp{\sf gen}}}$
\\
\>$\trstep{x}{{\sf gen/eval}\,\lf{({\sf lam}\,\lambda x.e)}\,x'}$
\\
\>\>$\tackon{\Theta}
       {x{:}\istrue{\susp{{\sf eval}\,\lf{({\sf lam}\,\lambda x.e)}}}}$
\end{tabbing}

We can use $T'$ to construct $T_2$ as follows:

\begin{tabbing}
$T_2 = ~$ \= \qquad \= $(x{:}\istrue{\susp{\sf gen}})$
\\
\>$T'$
\\
\>\>$\tackon{\Theta}{x'{:}\istrue{\susp{\sf gen}}}$
\\
\>$\trstep{y}{{\sf gen/retn}\,\lf{({\sf lam}\,\lambda x.e)}\,(\tfuser{x'}{\tbangr{({\sf value/lam}\,\lf{(\lambda x.e)})}})}$
\\
\>\>$\tackon{\Theta}
     {y{:}\istrue{\susp{{\sf retn}\,\lf{({\sf lam}\,\lambda x.e)}}}}$
\end{tabbing}

%%%%%%%%
%%%%%%%%
%%%%%%%%
\item 
  [Case $\trstep{y_1, y_2, y_3}{{\sf ev/app}\,\lf{e_1}\,\lf{e_2}\,x}$]~

\qquad
  $::
   \tackon{\Theta}
     {x{:}\istrue{\susp{{\sf eval}\,\lf{({\sf app}\,e_1\,e_2)}}}}$

\qquad\qquad
  $\leadsto
   \tackon{\Theta}
     {y_1{:}\istrue{\susp{{\sf eval}\,\lf{e_1}}}, ~
      y_2{:}\istrue{\susp{{\sf eval}\,\lf{e_2}}}, ~
      y_3{:}\istrue{\susp{{\sf cont2}\,\lf{\sf app1}}}}$
\medskip

Applying inversion (Part 1) to $T_1$, we have 

\begin{tabbing}
$T_1 = ~$ \= \qquad \= $(x{:}\istrue{\susp{\sf gen}})$
\\
\>$T'$
\\
\>\>$\tackon{\Theta}{x'{:}\istrue{\susp{\sf gen}}}$
\\
\>$\trstep{x}{{\sf gen/eval}\,\lf{({\sf app}\,e_1\,e_2)}\,x'}$
\\
\>\>$\tackon{\Theta}{x{:}\istrue{\susp{{\sf eval}\,\lf{({\sf app}\,e_1\,e_2)}}}}$
\end{tabbing}

We can use $T'$ to construct $T_2$ as follows:

\begin{tabbing}
$T_2 = ~$ \= \qquad \= $(x{:}\istrue{\susp{\sf gen}})$
\\
\>$T'$
\\
\>\>$\tackon{\Theta}{x'{:}\istrue{\susp{\sf gen}}}$
\\
\>$\trstep{y_1',y_2',y}{{\sf gen/cont2}\,\lf{{\sf app1}}\,(\tfuser{x'}{\tbangr{{\sf okf2/app1}}})}$
\\
\>$\trstep{y_1}{{\sf gen/eval}\,\lf{e_1}\,y_1'}$
\\
\>$\trstep{y_2}{{\sf gen/eval}\,\lf{e_2}\,y_2'}$
\\
\>\>$\tackon{\Theta}{y_1{:}\istrue{\susp{{\sf eval}\,\lf{e_1}}}, ~
      y_2{:}\istrue{\susp{{\sf eval}\,\lf{e_2}}}, ~
      y_3{:}\istrue{\susp{{\sf cont2}\,\lf{\sf app1}}}}$
\end{tabbing}

%%%%%%%%
%%%%%%%%
%%%%%%%%
\item 
  [Case $\trstep{y}{{\sf ev/app1}\,\lf{(\lambda x.\,e)}\,\lf{v_2}\,(\tfuser{x_1}{\tfuser{x_2}{x_3}})}$]~

\qquad
  $::
   \tackon{\Theta}{x_1{:}\istrue{\susp{{\sf retn}\,\lf{({\sf lam}\,\lambda x.\,e)}}}, ~
                   x_2{:}\istrue{\susp{{\sf retn}\,\lf{v_2}}}, ~
                   x_3{:}\istrue{\susp{{\sf cont2}\,\lf{\sf app1}}}}$

\qquad\qquad
  $\leadsto
   \tackon{\Theta}{y{:}\istrue{\susp{{\sf eval}\,\lf{([v_2/x]e)}}}}$

\medskip
Applying inversion (Part 2, twice, and then Part 4) to $T_1$, we have

\begin{tabbing}
$T_1 = ~$ \= \qquad \= $(x{:}\istrue{\susp{\sf gen}})$
\\
\>$T'$
\\
\>\>$\tackon{\Theta}{x'{:}\istrue{\susp{\sf gen}}}$
\\
\>$\trstep{x_1', x_2', x_3}
     {{\sf gen/cont2}\,\lf{\sf app1}\,(\tfuser{x'}{\tbangr{N}})}$
\\
\>$\trstep{x_1}
     {{\sf gen/retn}\,\lf{({\sf lam}\,\lambda x.e)}\,
        (\tfuser{x_1'}{\tbangr{N_1}})}$ 
\\
\>$\trstep{x_2}
     {{\sf gen/retn}\,\lf{v_2}\,(\tfuser{x_2'}{\tbangr{N_2}})}$
\\
\>\>$\tackon{\Theta}{x_1{:}\istrue{\susp{{\sf retn}\,\lf{({\sf lam}\,\lambda x.\,e)}}}, ~
                   x_2{:}\istrue{\susp{{\sf retn}\,\lf{v_2}}}, ~
                   x_3{:}\istrue{\susp{{\sf cont2}\,\lf{\sf app1}}}}$
\end{tabbing}

We can use $T'$ to construct $T_2$ as follows:
\begin{tabbing}
$T_2 = ~$ \= \qquad \= $(x{:}\istrue{\susp{\sf gen}})$
\\
\>$T'$
\\
\>\>$\tackon{\Theta}{x'{:}\istrue{\susp{\sf gen}}}$
\\
\>$\trstep{y}
     {{\sf gen/eval}\,\lf{([v_2/x]e)}\,x'}$
\\
\>\>$\tackon{\Theta}{y{:}\istrue{\susp{{\sf eval}\,\lf{([v_2/x]e)}}}}$
\end{tabbing}


\end{description}

\noindent
The other cases, corresponding to the rules ${\sf ev/unit}$, ${\sf
  ev/fail}$, ${\sf ev/catch}$, ${\sf ev/catcha}$, ${\sf ev/catchb}$,
${\sf ev/error}$, ${\sf ev/errerr}$, ${\sf ev/errret}$, and ${\sf
  ev/reterr}$ all follow the same lines: enumeration, inversion, and
reconstruction. 
\end{proof}

Note that, in the case corresponding to the rule ${\sf ev/app1}$, we
obtained but did not use three terms $\cdot \vdash N : {{\sf
    okf2}\,\lf{\sf app1}}$, $\cdot \vdash N_1 : {\sf value}\,\lf{({\sf
    lam}\,\lambda x.e)}$, and $\cdot \vdash N_2 : {{\sf
    value}\,\lf{v_2}}$. By traditional inversion on the structure of a
deductive derivation, we know that $N = {\sf okf2/app1}$ and $N_1 =
{\sf value/lam}\,\lf{(\lambda x.e)}$, but that was not necessary to
this theorem.


\section{From well-formed to well-typed states}
\label{sec:gen-ordertp}

In order to describe those expressions whose evaluations never get
stuck, we introduce object level types $\obj{\it tp}$ and define a
typing judgment $\obj{\Gamma \vdash e : {\it tp}}$.  We encode
object-level types as LF terms classified by the LF type ${\sf
  typ}$. The unit type $\interp{\one} = \lf{\sf unittp}$ classifies units
$\interp{\langle\rangle} = \lf{\sf unit}$, and the function type $\interp{{\it tp}_1
  \Rightarrow {\it tp}_2} = \lf{\sf arr}\,\interp{{\it
    tp}_1}\,\interp{{\it tp}_2}$ classifies lambda expressions.

\begin{figure}[tp]
\fvset{fontsize=\small,boxwidth=229pt}
\VerbatimInput{sls/gen-order-of.sls} 
\caption{Typing rules for expressions}
\label{fig:gen-order-of} 
\end{figure}

In a syntax-directed type system, each syntactic construct is associated
with a different typing rule.
These are the typing rules necessary for describing the language
constructs in Figure~\ref{fig:gen-order-prog}:
\[
\infer
{\obj{\Gamma \vdash \langle\rangle : \one} \mathstrut}
{\mathstrut}
\qquad
\infer
{\obj{\Gamma \vdash \lambda x.e : {\it tp' \Rightarrow tp}} \mathstrut}
{\obj{\Gamma, x{:}{\it tp'} \vdash e : {\it tp}} \mathstrut}
\qquad
\infer
{\obj{\Gamma \vdash e_1\,e_2 : {\it tp}} \mathstrut}
{\obj{\Gamma \vdash e_1 : {\it tp' \Rightarrow tp}}
 &
 \obj{\Gamma \vdash e_2 : {\it tp'}}
 \mathstrut}
\]
\[
\infer
{\obj{\Gamma \vdash {\sf fail} : {\it tp}} \mathstrut}
{}
\qquad
\infer
{\obj{\Gamma \vdash {\sf try}\,e_1\,{\sf ow}\,e_2 : {\it tp}} \mathstrut}
{\obj{\Gamma \vdash e_1 : {\it tp}} 
 &
 \obj{\Gamma \vdash e_2 : {\it tp}}
 \mathstrut}
\]
We can adequately encode derivations of the judgment
$\obj{x_1{:}{\it tp}_1, \ldots, x_n{:}{\it tp}_n \vdash e : {\it tp}}$ as 
\sls~derivations $\lf{x_1}{:}{\sf exp}, \ldots, \lf{x_n}{:}{\sf exp}; 
y_1 : \ispers{({\sf of}\,\lf{x_1}\,\interp{{\it tp}_1})}, \ldots,
y_n : \ispers{({\sf of}\,\lf{x_1}\,\interp{{\it tp}_n})}
\vdash {\sf of}\,\interp{e}\,\interp{\it tp}$ under the signature
in Figure~\ref{fig:gen-order-of}.

\begin{figure}[tp]
\fvset{fontsize=\small,boxwidth=229pt}
\VerbatimInput{sls/gen-ordertp.sls} 
\caption{Generative invariant: well-typed process states}
\label{fig:gen-ordertp} 
\end{figure}


This typing judgment allows us to describe well-formed initial states,
but it is not sufficient to describe intermediate states. To this end,
we describe typing rules for frames, refining the negative predicates
${\sf okf}\,\lf{f}$ and ${\sf okf2}\,\lf{f}$ from
Figure~\ref{fig:gen-order}. The \sls~proposition describing well-typed
sequential frames is $({\sf off}\,\lf{f}\,\interp{{\it
    tp}'}\,\interp{\it tp})$. This proposition expresses that the frame
$\lf{f}$ {\it expects} a returned result with type $\obj{\it tp'}$ and
{\it produces} a computation with type $\obj{{\it tp}}$.\footnote{The
  judgment we encode in \sls~as $({\sf off}\,\lf{f}\,\interp{{\it
      tp}'}\,\interp{\it tp})$ is written $\obj{f : {\it tp}'
    \Rightarrow {\it tp}}$ in \cite[Chapter 27]{harper12practical}.}
The parallel version is $({\sf off}\,\lf{f}\,\interp{{\it
    tp}_1}\,\interp{{\it tp}_2}\,\interp{\it tp})$, and expects two
sub-computation with types $\obj{{\it tp}_1}$ and $\obj{{\it tp}_2}$,
respectively, in order to produce a computation of type $\obj{{\it
    tp}}$. These judgments are given in Figure~\ref{fig:gen-ordertp}. 

The generative rules in Figure~\ref{fig:gen-ordertp} are our first use
of an {\it indexed} nonterminal, ${\sf gen}\,\interp{\it tp}$, which
generates computations that, upon successful return, will produce
values $\obj{v}$ of type $\obj{\cdot \vdash v : {\it tp}}$. 

\subsection{Inversion}

The structure of inversion lemmas is entirely unchanged
aside for accounting for type indices. Establishing
a pattern we will follow for the rest of the chapter, we only state
two cases of the inversion lemma, the one corresponding to 
${\sf gen/eval}$ and the one corresponding to ${\sf gen/cont}$. 
These two cases suffice to set up the template that all other cases
follow. 

\bigskip
\begin{lemma}[Inversion -- Figure~\ref{fig:gen-order}, partial]~
\begin{enumerate}
\item If 
   $T :: (x{:}\istrue{\susp{{\sf gen}\,\lf{{\it tp}_0}}}) 
         \leadsto^*_{\siggenordertp}
         \tackon{\Theta}{y{:}\istrue{\susp{{\sf eval}\,\lf{e}}}}$,
\\ then 
   $T = \left(T'; \trstep{y}{{\sf gen/eval}\,\lf{{\it tp}}\,\lf{e}\,(\tfuser{x'}{\tbangr{N}})}\right)$,
\\ where $\cdot \vdash_{\siggenordertp} N : {\sf of}\,\lf{e}\,\lf{{\it tp}}$
\medskip
\item If 
   $T :: (x{:}\istrue{\susp{{\sf gen}\,\lf{{\it tp}_0}}})
         \leadsto^*_{\siggenordertp}
         \tackon{\Theta}{y_1{:}\istrue{\susp{{\sf gen}\,\lf{{\it tp}'}}}, ~
                         y_2{:}\istrue{\susp{{\sf cont}\,\lf{f}}}}$,
\\ then 
   $T = \left(T'; \trstep{y_1,y_2}{{\sf gen/cont}\,\lf{{\it tp}}\,\lf{f}\,\lf{{\it tp}'}\,(\tfuser{x'}{\tbangr{N}})}\right)$,
\\ where 
   $\cdot \vdash_{\siggenordertp} N : {{{\sf off}\,\lf{f}\,\lf{{\it tp}'}\,\lf{{\it tp}}}}$.
\medskip
\end{enumerate}
In each instance above, 
$T' :: (x{:}\istrue{\susp{{\sf gen}\,\lf{{\it tp}_0}}}) \leadsto^*_{\siggenordertp}
          \tackon{\Theta}{x'{:}\istrue{\susp{{\sf gen}\,\lf{{\it tp}}}}}$,
where the variables $x$ and $x'$ may or may not
be the same. (They are the same iff $T' = \emptytrace$, and if they
are the same that implies $\lf{{\it tp}_0} = \lf{{\it tp}}$.)
\end{lemma}
\bigskip



\subsection{Preservation}


Theorem~\ref{thm:siggenordertp} only differs from
Theorem~\ref{thm:siggenorder} because it mentions the type index.
Each object-level type $\lf{{\it tp}_0}$ describes a different world,
and evaluation under the rules in Figure~\ref{fig:gen-order-prog}
always stays within the same world.

\bigskip
\begin{theorem}[$\siggenordertp$ is a generative invariant]
\label{thm:siggenordertp}
If $T_1 :: (x{:}\istrue{\susp{{\sf gen}\,\lf{{\it tp}_0}}}) \leadsto^*_{\siggenordertp} 
   \Delta$ and $S :: \restrictsig{\Delta}{} \leadsto \Delta'$
under the signature from Figure~\ref{fig:gen-order-prog}, then
$T_2 :: (x{:}\istrue{\susp{{\sf gen}\,\lf{{\it tp}_0}}}) \leadsto^*_{\siggenordertp} 
   \Delta'$.
\end{theorem}

\bigskip
In the proof of Theorem~\ref{thm:siggenorder}, we observed that the
applicable inversion on the generative trace gave us derivations like
$\cdot \vdash N : {{\sf okf2}\,\lf{\sf app1}}$. We did not need these
side derivations to complete the proof, but we noted that they were
amenable to traditional inversion. Traditional inversion will be
critical in proving that the generative invariant described by
$\siggenordertp$ is preserved. Describing, proving, and mechanizing
traditional inversion lemmas on deductive derivation is a solved
problem; we merely point out when we are using a traditional inversion
property in the proof below.


\begin{proof} As always, the proof proceeds by enumeration, inversion,
  and reconstruction. We give two representative cases: 

\begin{description}

\item 
  [Case $\trstep{y}{{\sf ev/app1}\,\lf{(\lambda x.\,e)}\,\lf{v_2}\,(\tfuser{x_1}{\tfuser{x_2}{x_2}})}$]~

\qquad
  $::
   \tackon{\Theta}{x_1{:}\istrue{\susp{{\sf retn}\,\lf{({\sf lam}\,\lambda x.\,e)}}}, ~
                   x_2{:}\istrue{\susp{{\sf retn}\,\lf{v_2}}}, ~
                   x_3{:}\istrue{\susp{{\sf cont2}\,\lf{\sf app1}}}}$

\qquad\qquad
  $\leadsto
   \tackon{\Theta}{y{:}\istrue{\susp{{\sf eval}\,\lf{([v_2/x]e)}}}}$

\medskip
Applying inversion to $T_1$, we have

\begin{tabbing}
$T_1 = ~$ \= \qquad \= $(x{:}\istrue{\susp{{\sf gen}\,\lf{{\it tp}_0}}})$
\\
\>$T'$
\\
\>\>$\tackon{\Theta}{x'{:}\istrue{\susp{{\sf gen}\,\lf{{\it tp}}}}}$
\\
\>$\trstep{x_1', x_2', x_3}
     {{\sf gen/cont2}\,\lf{{\it tp}}\,\lf{\sf app1}\,
         \lf{{\it tp}''}\,\lf{{\it tp}'}\,
         (\tfuser{x'}{\tbangr{N}})}$
\\ %%
\>\>$\tackon{\Theta}
     {x_1'{:}\istrue{\susp{{\sf gen}\,\lf{{\it tp}''}}}, ~
      x_2'{:}\istrue{\susp{{\sf gen}\,\lf{{\it tp}'}}}, ~
      x_3{:}\istrue{\susp{{\sf cont}\,\lf{\sf app1}}}}$
\\
\>$\trstep{x_1}
     {{\sf gen/retn}\,\lf{tp''}\,\lf{({\sf lam}\,\lambda x.e)}\,}
         (\tfuser{x_1'}{\tfuser{\tbangr{N_1}}{\tbangr{N_{v1}}}})$
%        (\tfuser{x_1'}{\tfuser{\tbangr{N_1}}{\tbangr{N_{v1}}}})}$ 
\\
\>$\trstep{x_2}
     {{\sf gen/retn}\,\lf{v_2}\,(\tfuser{x_2'}{\tfuser{\tbangr{N_2}}{\tbangr{N_{v2}}}})}$
\\
\>\>$\tackon{\Theta}{x_1{:}\istrue{\susp{{\sf retn}\,\lf{({\sf lam}\,\lambda x.\,e)}}}, ~
                   x_2{:}\istrue{\susp{{\sf retn}\,\lf{v_2}}}, ~
                   x_3{:}\istrue{\susp{{\sf cont2}\,\lf{\sf app1}}}}$
\end{tabbing}
where
\begin{itemize}
\item[$\bullet$] $\cdot \vdash N : {\sf off2}\,\lf{\sf app1}\,\lf{{\it
      tp}''}\,\lf{{\it tp}'}\,\lf{{\it tp}}$.  By traditional
  inversion we know $\lf{\it{tp}''} = \lf{{\sf arr}\,{\it tp}'\,{\it
      tp}}$ and $N = {\sf off2/app1}\,\lf{{\it tp}'}\,\lf{{\it tp}}$.
\item[$\bullet$] $\cdot \vdash N_1 : {\sf of}\,\lf{({\sf lam}\,\lambda
    x.e)}\,\lf{tp''}$. By traditional inversion we know $N_1 = {\sf
    of/app}\,\tbangr{(\lambda \lf{x},{\it dx}.\,N_1')}$, where
  $\lf{x}{:}{\sf exp}; {\it dx} : \ispers{{\sf of}\,\lf{x}\,\lf{\it
      tp'}} \vdash N_1' : \isconc{{\sf of}\,\lf{e}\,\lf{\it
        tp}}$.
\item[$\bullet$] $\cdot \vdash N_2 : {\sf of}\,\lf{v_2}\,\lf{{\it tp}'}$.
\end{itemize}

With these derivations, 
variable substitution (Theorem~\ref{thm:varsubst}), and cut
admissibility (Theorem~\ref{thm:ord-cut}), we have a derivation of
$\cdot \vdash \rsubst{N_2}{\it dx}{(\lf{[v_2/x]}N_1')} : {\sf
  of}\,\lf{([v_2/x]e)}\,\lf{\it tp}$.\footnote{We know by
  subordination that $\lf{x}$ is not free in $\lf{\it tp}$, so
  $\lf{[v_2/x]{\it tp}} = \lf{\it tp}$.}  We can therefore use $T'$ to
construct $T_2$ as follows:
\begin{tabbing}
$T_2 = ~$ \= \qquad \= $(x{:}\istrue{\susp{{\sf gen}\,\lf{{\it tp}_0}}})$
\\
\>$T'$
\\
\>\>$\tackon{\Theta}{x'{:}\istrue{\susp{{\sf gen}\,\lf{\it tp}}}}$
\\
\>$\trstep{y}
     {{\sf gen/eval}\,\lf{tp}\,\lf{([v_2/x]e)}\,(\tfuser{x'}{\tbangr{(\rsubst{N_2}{\it
  dx}{(\lf{[v_2/x]}N_1')})}})}$
\\
\>\>$\tackon{\Theta}{y{:}\istrue{\susp{{\sf eval}\,\lf{([v_2/x]e)}}}}$
\end{tabbing}

%%%%
%%%%
%%%%
\item 
  [Case $\trstep{y_1,y_2}{{\sf ev/catch}\,\lf{(\lambda x.\,e)}\,\lf{v_2}\,x}$]~
 
\qquad $:: \tackon{\Theta}{x{:}\istrue{\susp{{\sf eval}\,\lf{({\sf catch}\,e_1\,e_2)}}}}
       \leadsto 
        \tackon{\Theta}{y_1{:}\istrue{\susp{{\sf eval}\,\lf{e_1}}}, ~
                   y_2{:}\istrue{\susp{{\sf handle}\,\lf{e_2}}}}$]~

\medskip
Applying inversion to $T_1$, we have

\begin{tabbing}
$T_1 = ~$ \= \qquad \= $(x{:}\istrue{\susp{{\sf gen}\,\lf{{\it tp}_0}}})$
\\
\>$T'$
\\
\>\>$\tackon{\Theta}{x'{:}\istrue{\susp{{\sf gen}\,\lf{{\it tp}}}}}$
\\
\>$\trstep{x}
     {{\sf gen/eval}\,\lf{\it tp}\,\lf{({\sf catch}\,e_1\,e_2)}\,(\tfuser{x'}{\tbangr{N}})}$
\\
\>\>$\tackon{\Theta}{x{:}\istrue{\susp{{\sf eval}\,\lf{({\sf catch}\,e_1\,e_2)}}}}$
\end{tabbing}
where $\cdot \vdash N : \sf of\,\lf{({\sf catch}\,e_1\,e_2)}\,\lf{\it tp}$. 

\medskip
By traditional inversion, we 
know that $N = {\sf of/catch}\,\tbangr{N_2}\,\tbangr{N_1}$, where
 $\vdash N_1 : {\sf of}\,\lf{e_1}\,\lf{\it tp}$ and $\vdash N_2 :
{\sf of}\,\lf{e_2}\,\lf{\it tp}$.
We can therefore use $T'$ to construct $T_2$ as follows:

\begin{tabbing}
$T_1 = ~$ \= \qquad \= $(x{:}\istrue{\susp{{\sf gen}\,\lf{{\it tp}_0}}})$
\\
\>$T'$
\\
\>\>$\tackon{\Theta}{x'{:}\istrue{\susp{{\sf gen}\,\lf{{\it tp}}}}}$
\\
\>$\trstep{y_1',y_2}{{\sf gen/handle}\,\lf{\it tp}\,\lf{e_2}\,(\tfuser{x'}{\tbangr{N_2}})}$
\\
\>$\trstep{y_1}{{\sf gen/eval}\,\lf{\it tp}\,\lf{e_1}\,(\tfuser{y_1'}{\tbangr{N_1}})}$
\\
\>\>$\tackon{\Theta}{y_1{:}\istrue{\susp{{\sf eval}\,\lf{e_1}}}, ~
                   y_2{:}\istrue{\susp{{\sf handle}\,\lf{e_2}}}}$
\end{tabbing}


\end{description}

\noindent
The other cases follow the same pattern.
\end{proof}

Dealing with type preservation is, in an
sense, no more difficult than dealing with well-formedness
invariants. % Aside from the issues of adapting inversion theorems to
%generative traces, which were considered already in
%Section~\ref{sec:gen-order} and Theorem~\ref{thm:siggenorder},
Theorem~\ref{thm:siggenordertp} furthermore follows the contours of a standard
progress and preservation proof for an abstract machine like Harper's
$\mathcal K\{{\sf nat}{\rightharpoonup}\}$ \cite[Chapter
27]{harper12practical}.  Unlike the on-paper formalism used by Harper,
the addition of parallel evaluation in our specification does not
further complicate the statement or proof of the preservation theorem.


\section{State}
\label{sec:gen-state}

Ambient state, encoded in mobile and persistent propositions, was used
to describe mutable storage in Section~\ref{sec:mutable-storage},
call-by-need evaluation in Section~\ref{sec:call-by-need}, and the
environment semantics in Section~\ref{sec:environment-semantics}. The
technology needed to describe generative invariants for each of these
specifications is similar. We will consider the extension of our
program from Figure~\ref{fig:gen-order-prog} with the semantics of
mutable storage from Figure~\ref{fig:ssos-mutable}. This specification
adds a mobile atomic proposition ${\sf cell}\,\lf{l}\,\lf{v}$, which
the generative signature will treat as a new terminal.

The intuition behind mutable cells is that they exist in 
tandem with locations $\lf{l}$ of LF type ${\sf mutable\_loc}$,
giving the non-control part of a process state the following
general form:
\[\left(\lf{l_1}{:}{\sf mutable\_loc},\ldots,\lf{l_n}{:}{\sf mutable\_loc};
  ~~ \iseph{\susp{{\sf cell}\,\lf{l_1}\,\lf{v_1}}}, 
  ~~ \ldots, 
  ~~ \iseph{\susp{{\sf cell}\,\lf{l_n}\,\lf{v_n}}}, 
  ~~ \ldots\right)\]
%
Naively, we might attempt to describe such process 
states with the block-like rule 
${\sf gen/cell/bad} : \forall \lf{v}.\, {!}{\sf
  value}\,\lf{v} \lefti \{ \exists \lf{l}. {\sf cell}\,\lf{l}\,\lf{v}
\}$. The problem with such a specification is that it makes 
cells unable to refer to themselves, a situation that can easily
happen in practice. A canonical example, using back-patching to
implement recursion, is traced out 
in Figure~\ref{fig:bigbackpatch}, which
describes a trace classified by:

{\small\begin{align*}
&
\left(\cdot; ~~
 x_0{:}\istrue{\susp{{\sf eval}\,
  \interp{{\sf let}\,f = ({\sf ref}\,\lambda x. \langle\rangle) \,{\sf in}\,
          {\sf let}\,x = (f := \lambda x. ({!}f) x)\,{\sf in}\,e}}}
\right) ~~ \leadsto^*
\\
& 
\left(
\lf{l_1}{:}{\sf mutable\_loc}; ~~
y_2{:}\iseph{\susp{{\sf cell}\,\lf{l_1}\,
  \lf{({\sf lam}\,\lambda x.\,{\sf app}\,({\sf get}\,({\sf loc}\,l_1))\,x)}}},
 ~~
x_{17}{:}\istrue{\susp{{\sf eval}\,
  \lf{[({\sf loc}\,l_1)/f, {\sf unit}/x]\interp{e})}}}
\right)
\end{align*}}

\begin{sidewaysfigure}[p]\label{fig:bigbackpatch}\small
\begin{align*}
&\qquad 
x_0{:}\susp{{\sf eval}\,
  \interp{{\sf let}\,f = ({\sf ref}\,\lambda x. \langle\rangle) \,{\sf in}\,
          {\sf let}\,x = (f := \lambda x. ({!}f) x)\,{\sf in}\,e}}
\\
& \trstep{x_1,x_2}{{\sf ev/let1}\,\ldots\,x_0}
\\
&\qquad
x_1{:}\susp{{\sf eval}\,\interp{{\sf ref}\,\lambda x. \langle\rangle}}, ~~
x_2{:}\susp{{\sf cont}\,
  \lf{({\sf let1}\,\lambda f.\,
  \interp{{\sf let}\, x = (f := \lambda x. ({!}f) x)\,{\sf in}\,e})}}
\\
& \trstep{x_3, x_4}{{\sf ev/ref}\,\ldots\,x_1}
\\
&\qquad
x_3{:}\susp{{\sf eval}\,\interp{\lambda x. \langle\rangle}}, ~~
x_4{:}\susp{{\sf cont}\,\lf{\sf ref1}}, ~~
x_2{:}\susp{{\sf cont}\,
  \lf{({\sf let1}\,\lambda f.\,
  \interp{{\sf let}\, x = (f := \lambda x. ({!}f) x)\,{\sf in}\,e})}}
\\
& \trstep{x_5}{{\sf ev/lam}\,\ldots\,x_3}
\\
&\qquad 
x_5{:}\susp{{\sf retn}\,\interp{\lambda x. \langle\rangle}}, ~~
x_4{:}\susp{{\sf cont}\,\lf{\sf ref1}}, ~~
x_2{:}\susp{{\sf cont}\,
  \lf{({\sf let1}\,\lambda f.\,
  \interp{{\sf let}\, x = (f := \lambda x. ({!}f) x)\,{\sf in}\,e})}}
\\
& \trstep{x_6,y_1}{{\sf ev/ref1}\,\ldots\,(\tfuser{x_5}{x_4})}
\\
&\qquad
y_1{:}\susp{{\sf cell}\,\lf{l_1}\,\interp{\lambda x. \langle\rangle}}, ~~
x_6{:}\susp{{\sf retn}\,\lf{{\sf loc}\,l_1}}, ~~
x_2{:}\susp{{\sf cont}\,
  \lf{({\sf let1}\,\lambda f.\,
  \interp{{\sf let}\, x = (f := \lambda x. ({!}f) x)\,{\sf in}\,e})}}
\\
& \trstep{x_7}{{\sf ev/let1}\,\ldots\,(\tfuser{x_6}{x_2})}
\\
&\qquad
y_1{:}\susp{{\sf cell}\,\lf{l_1}\,\interp{\lambda x. \langle\rangle}}, ~~
x_7{:}\susp{{\sf eval}\,
  \lf{({\sf let}\,({\sf set}\,\lf{({\sf loc}\,l_1)}\,({\sf lam}\,\lambda x.\,{\sf app}\,({\sf get}\,({\sf loc}\,l_1))\,x))\,\lambda x.\,([({\sf loc}\,l_1)/f]\interp{e}))}}
\\
& \trstep{x_8,x_9}{{\sf ev/let}\,\ldots x_7}
\\
&\qquad
y_1{:}\susp{{\sf cell}\,\lf{l_1}\,\interp{\lambda x. \langle\rangle}}, ~~
x_8{:}\susp{{\sf eval}\,
  \lf{({\sf set}\,\lf{({\sf loc}\,l_1)}\,({\sf lam}\,\lambda x.\,{\sf app}\,({\sf get}\,({\sf loc}\,l_1))\,x))}}, ~~
x_9{:}\susp{{\sf cont}\,
  \lf{({\sf let1}\,\lambda x.\,([({\sf loc}\,l_1)/f]\interp{e}))}}
\\
& \trstep{x_{10},x_{11}}{{\sf ev/set}\,\ldots\,x_8}
\\
&\qquad
y_1{:}\susp{{\sf cell}\,\lf{l_1}\,\interp{\lambda x. \langle\rangle}}, ~~
x_{10}{:}\susp{{\sf eval}\,
  \lf{({\sf loc}\,l_1)}}, ~~
x_{11}{:}\susp{{\sf cont}\,
  \lf{({\sf set1}\,({\sf lam}\,\lambda x.\,{\sf app}\,({\sf get}\,({\sf loc}\,l_1))\,x))}}, ~~
x_9{:}\susp{{\sf cont}\,
  \lf{({\sf let1}\,\lambda x.\,([({\sf loc}\,l_1)/f]\interp{e}))}}
\\
& \trstep{x_{12}}{{\sf ev/loc}\,\ldots\,x_{10}}
\\
&\qquad
y_1{:}\susp{{\sf cell}\,\lf{l_1}\,\interp{\lambda x. \langle\rangle}}, ~~
x_{12}{:}\susp{{\sf retn}\,
  \lf{({\sf loc}\,l_1)}}, ~~
x_{11}{:}\susp{{\sf cont}\,
  \lf{({\sf set1}\,({\sf lam}\,\lambda x.\,{\sf app}\,({\sf get}\,({\sf loc}\,l_1))\,x))}}, ~~
x_9{:}\susp{{\sf cont}\,
  \lf{({\sf let1}\,\lambda x.\,([({\sf loc}\,l_1)/f]\interp{e}))}}
\\
& \trstep{x_{13},x_{14}}{{\sf ev/set1}\,\ldots\,(\tfuser{x_{12}}{x_{11}})}
\\
&\qquad
y_1{:}\susp{{\sf cell}\,\lf{l_1}\,\interp{\lambda x. \langle\rangle}}, ~~
x_{13}{:}\susp{{\sf eval}\,
  \lf{({\sf lam}\,\lambda x.\,{\sf app}\,({\sf get}\,({\sf loc}\,l_1))\,x)}}, ~~
x_{14}{:}\susp{{\sf cont}\,
  \lf{({\sf set2}\,l_1)}}, ~~
x_9{:}\susp{{\sf cont}\,
  \lf{({\sf let1}\,\lambda x.\,([({\sf loc}\,l_1)/f]\interp{e}))}}
\\
& \trstep{x_{15}}{{\sf ev/lam}\,\ldots\,x_{13}}
\\
&\qquad
y_1{:}\susp{{\sf cell}\,\lf{l_1}\,\interp{\lambda x. \langle\rangle}}, ~~
x_{15}{:}\susp{{\sf retn}\,
  \lf{({\sf lam}\,\lambda x.\,{\sf app}\,({\sf get}\,({\sf loc}\,l_1))\,x)}}, ~~
x_{14}{:}\susp{{\sf cont}\,
  \lf{({\sf set2}\,l_1)}}, ~~
x_9{:}\susp{{\sf cont}\,
  \lf{({\sf let1}\,\lambda x.\,([({\sf loc}\,l_1)/f]\interp{e}))}}
\\
& \trstep{x_{16},y_2}{{\sf ev/set2}\,\ldots\,(\tfuser{x_{15}}{\tfuser{x_{14}}{y_1}})}
\\
&\qquad
y_2{:}\susp{{\sf cell}\,\lf{l_1}\,
  \lf{({\sf lam}\,\lambda x.\,{\sf app}\,({\sf get}\,({\sf loc}\,l_1))\,x)}}, ~~
x_{16}{:}\susp{{\sf retn}\,
  \lf{\sf unit}}, ~~
x_9\susp{{\sf cont}\,
  \lf{({\sf let1}\,\lambda x.\,([({\sf loc}\,l_1)/f]\interp{e}))}}
\\
& \trstep{x_{17}}{{\sf ev/let1}\,\ldots\,(\tfuser{x_{16}}{x_9})}
\\
&\qquad
y_2{:}\susp{{\sf cell}\,\lf{l_1}\,
  \lf{({\sf lam}\,\lambda x.\,{\sf app}\,({\sf get}\,({\sf loc}\,l_1))\,x)}}, ~~
x_{17}{:}\susp{{\sf eval}\,
  \lf{[({\sf loc}\,l_1)/f, {\sf unit}/x]\interp{e})}}
\end{align*}
\caption{Back-patching. Judgments ($\mtrue$ and $\meph$) and
  arguments corresponding to implicit quantifiers are elided.}
\end{sidewaysfigure}

The name of this problem is {\it parameter dependency} -- the term
$\lf{v}$ in ${\sf gen/cell/bad}$ has to be instantiated before the
parameter $\lf{l}$ is introduced. As a result, the trace in
Figure~\ref{fig:bigbackpatch} includes a step
\[\trstep{x_{16},y_2}{{\sf
    ev/set2}\,\ldots\,(\tfuser{x_{15}}{\tfuser{x_{14}}{y_1}})}\] that
transitions from a state that can be described by
Figure~\ref{fig:gen-order} extended with ${\sf gen/cell/bad}$ to a
state that cannot be described by this signature. Thus, the extended
signature is not a generative invariant.

\begin{figure}[t]
\fvset{fontsize=\small,boxwidth=229pt}
\VerbatimInput{sls/gen-state.sls} 
\caption{Generative invariant: well-typed mutable storage}
\label{fig:gen-state} 
\end{figure}

The solution is to create cells in two steps. The first rule, a ${\sf
  promise}$ rule, creates the location $\lf{l}$ and associates a mobile
nonterminal ${\sf gencell}$ with that location. A second ${\sf
  fulfill}$ rule consumes that nonterminal and creates the actual
mutable cell.  Because ${\sf gencell}$ is a mobile nonterminal, the
promise {\it must} be fulfilled in order for the final state to pass
through the restriction operation. As we have already seen,
there is not much of a technical difference between well-formedness
invariants and well-typedness invariants; Figure~\ref{fig:gen-state}
describes a generative signature that captures type information. 
This specification introduces
two nonterminals. The first is the aforementioned mobile nonterminal
${\sf gencell}\,\lf{l}$, representing the promise to
eventually create a cell corresponding to the location $\lf{l}$.  
The second is a
persistent nonterminal ${\sf ofcell}\,\lf{l}\,\lf{\it tp}$. The
collection of ${\sf ofcell}$ propositions introduced by a generative
trace collectively plays the role of a {\it store typing} in
\cite[Chapter 13]{pierce02types} or a {\it signature} in \cite[Chapter
35]{harper12practical}.

\subsection{Inversion}

When we add mutable state, we must significantly generalize the 
{\it statement} of inversion lemmas. Derivations and
expressions now exist in a world with arbitrary locations $\lf{l}{:}{\sf
  mutable\_loc}$ that are paired with persistent propositions
$\ispers{{\sf ofcell}\,\lf{l}\,\lf{\it tp}}$. 
This purely persistent
world fits the pattern of regular worlds. 
As such, it can be described either with the
single rule
$\forall \lf{\it tp}.\,\{ \exists \lf{l}.\,{\sf
    ofcell}\,\lf{l}\,\lf{\it tp}\}$ or with the equivalent block
\[{\sf some} ~ \lf{\it tp}{:}{\sf
  typ} ~ {\sf block} ~ \lf{l}{:}{\sf mutable\_loc}, x : \ispers{\susp{{\sf
    ofcell}\,\lf{l}\,\lf{\it tp}}}.\]


\begin{lemma}[Inversion -- Figure~\ref{fig:gen-state}, partial]~
\begin{enumerate}
\item If 
   $T :: (\cdot; x{:}\istrue{\susp{{\sf gen}\,\lf{{\it tp}_0}}})
         \leadsto^*_{\siggenstate}
         (\Psi; \tackon{\Theta}
            {y{:}\istrue{\susp{{\sf eval}\,\lf{e}}}})$,
\\ then 
   $T = \left(T'; \trstep{y}{{\sf gen/eval}\,\lf{{\it tp}}\,\lf{e}\,
                                  (\tfuser{x'}{\tbangr{N}})}\right)$,
\\ where
   $\Psi; \Delta \vdash_{\siggenstate} N : {{\sf of}\,\lf{e}\,\lf{{\it tp}}}$,
\\ $T' :: (\cdot; x{:}\istrue{\susp{{\sf gen}\,\lf{{\it tp}_0}}})
       \leadsto^*_{\siggenstate}
       (\Psi'; \tackon{\Theta}
          {x'{:}\istrue{\susp{{\sf gen}\,\lf{{\it tp}}}}})$, 
\\ and $\Delta$ is the persistent part of 
   $\tackon{\Theta}
          {x'{:}\istrue{\susp{{\sf gen}\,\lf{{\it tp}}}}}$.
   
\medskip
\item If 
   $T :: (\cdot; x{:}\istrue{\susp{{\sf gen}\,\lf{{\it tp}_0}}})
         \leadsto^*_{\siggenstate}
         (\Psi; \tackon{\Theta}
            {y_1{:}\istrue{\susp{{\sf gen}\,\lf{{\it tp}'}}}, ~
             y_2{:}\istrue{\susp{{\sf cont}\,\lf{f}}}})$,
\\ then 
   $T = \left(T'; \trstep{y_1,y_2}
              {{\sf gen/cont}\,\lf{{\it tp}}\,\lf{f}\,\lf{{\it tp}'}\,
                (\tfuser{x'}{\tbangr{N}})}\right)$,
\\ where 
   $\Psi; \Delta \vdash_{\siggenstate} N : 
       {{{\sf off}\,\lf{f}\,\lf{{\it tp}'}\,\lf{{\it tp}}}}$,
\\ $T' :: (\cdot; x{:}\istrue{\susp{{\sf gen}\,\lf{{\it tp}_0}}})
       \leadsto^*_{\siggenstate}
       (\Psi'; \tackon{\Theta}
          {x'{:}\istrue{\susp{{\sf gen}\,\lf{{\it tp}}}}})$,
\\ and $\Delta$ is the persistent part of 
   $\tackon{\Theta}
          {x'{:}\istrue{\susp{{\sf gen}\,\lf{{\it tp}}}}}$.


\medskip
\item If $T :: (\cdot; x{:}\istrue{\susp{{\sf gen}\,\lf{{\it tp}_0}}})
         \leadsto^*_{\siggenstate} 
         (\Psi; \tackon{\Theta}
            {y{:}\istrue{\susp{{\sf cell}\,\lf{{\it l}}\,\lf{v}}}})$,
\\ then $T = (T'; \trstep{y}{{\sf gencell/fulfill}\,\lf{l}\,\lf{\it tp}\,\lf{v}\,(\tfuser{x'}{\tfuser{x_t}{\tfuser{\tbangr{N}}{\tbangr{N_v}}}})})$,
\\ where $x_t{:}\ispers{\susp{{\sf ofcell}\,\lf{l}\,\lf{\it tp}}} \in \Delta$,
   $\Psi; \Delta \vdash_{\siggenstate} N : {\sf of}\,\lf{v}\,\lf{\it tp}$,
   $\Psi; \Delta \vdash_{\siggenstate} N_v : {\sf value}\,\lf{v}$,
\\ $T' :: (\cdot; x{:}\istrue{\susp{{\sf gen}\,\lf{{\it tp}_0}}})
       \leadsto^*_{\siggenstate}
       (\Psi'; \tackon{\Theta}
          {x'{:}\iseph{\susp{{\sf gencell}\,\lf{l}}}})$,
\\ and $\Delta$ is the persistent part of 
   $\tackon{\Theta}
          {x'{:}\iseph{\susp{{\sf gencell}\,\lf{l}}}}$.
\end{enumerate}
\end{lemma}
\bigskip

Despite complicating the statement of inversion theorems, the addition
of mutable state does nothing to change the structure 
of these theorems.
The new inversion lemma (part 3 above) follows the
pattern established in Section~\ref{sec:inversion-genorder}.

\subsection{Uniqueness}

To prove that our generative invariant for mutable storage is
maintained, we need one property besides inversion; we'll refer to it
as the {\it unique index} property. This is the property that, under
the generative signature described by $\siggenstate$, locations always
map {\it uniquely} to persistent positive propositions $x_t{:}{\sf
  ofcell}\,\lf{l}\,\lf{\it tp}$.

\bigskip
\begin{lemma}[Unique indices of $\siggenstate$]~
\begin{enumerate}
\item
If $T :: (\cdot; x{:}\istrue{\susp{{\sf gen}\,\lf{{\it tp}_0}}})
         \leadsto^*_{\siggenstate}
         (\Psi; \Delta)$,
\\ ${x}{:}\ispers{\susp{{\sf ofcell}\,\lf{l}\,\lf{\it tp}}} \in \Delta$, 
\\ and 
${y}{:}\ispers{\susp{{\sf ofcell}\,\lf{l}\,\lf{{\it tp}'}}} \in \Delta$, 
\\ then $x = y$ and $\lf{tp} = \lf{{\it tp}'}$
\end{enumerate}
\end{lemma}

\begin{proof}
Induction on the structure of the trace $T$. 
\end{proof}


% We have to know that, given
% the persistent proposition ${\sf ofcell}\,\lf{l}\,\lf{{\it tp}}$ and
% the mobile proposition ${\sf gencell}\,\lf{l}\,\lf{{\it tp}'}$, we
% need to know that $\lf{{\it tp}} = \lf{{\it tp}'}$.

% $\{ {\sf ofcell/1} \}$
% $\{ {\sf gencell/1}, {\sf cell/1} \}$
% $\{ {\sf susp/1}, {\sf blackhole/1}, {\sf bind/1} \}$

% While it is a subtle point, unique indices are a property of the logical
% framework, but not the logic. 

\subsection{Preservation}

As it was with inversion, the statement of preservation is
substantially altered by the addition of locations and mutable state,
even though the structure of the proof is not.  In particular, because
${\sf ofcell}$ is a {\it persistent} nonterminal, we have to expressly
represent the fact that the restriction operator $\restrictsig{(\Psi;
  \Delta)}{}$ will modify the context $\Delta$ by removing the store
typing.

\bigskip
\begin{theorem}[$\siggenstate$ is a generative invariant]
\label{thm:siggenstate}
If $T_1 :: (\cdot; x{:}\istrue{\susp{{\sf gen}\,\lf{{\it tp}_0}}}) 
   \leadsto^*_{\siggenordertp} 
   (\Psi; \Delta)$ and 
   $S :: \restrictsig{(\Psi; \Delta)}{} \leadsto (\Psi'; \Delta')$
under the combined signature from Figure~\ref{fig:gen-order-prog}
and Figure~\ref{fig:ssos-mutable}, then
$(\Psi'; \Delta') = \restrictsig{(\Psi'; \Delta'')}{}$ 
for some $\Delta''$ such that 
$T_2 :: (\cdot; x{:}\istrue{\susp{{\sf gen}\,\lf{{\it tp}_0}}}) 
   \leadsto^*_{\siggenordertp} 
   (\Psi'; \Delta'')$.
\end{theorem}

\begin{proof}
As always, the proof proceeds by enumeration, inversion, and reconstruction. 
All the cases are\ldots 
\end{proof}

% \subsection{Store typing}


% \subsection{Environment semantics}

\section{Destination-passing}
\label{sec:gen-destinations}

Generative invariants can be used to describe the invariants 
associated with the destination-passing style specifications . Essentially,
the indexing analysis 

\begin{figure}[tp]
\fvset{fontsize=\small,boxwidth=229pt}
\VerbatimInput{sls/gen-destinations.sls} 
\caption{Generative invariant: destination-passing}
\label{fig:gen-destinations} 
\end{figure}

The key issue is again the inversion lemma; the destination-passing
style specification in Figure~\ref{fig:gen-destinations}

\bigskip
\begin{lemma}[Inversion -- Figure~\ref{fig:gen-destinations}, partial]~
\label{lemma:inversion-destinations}
\begin{enumerate}
\item If 
   $T :: (\cdot; x{:}\istrue{\susp{{\sf gen}\,\lf{{\it tp}_0}\,\lf{d_0}}})
         \leadsto^*_{\siggendests}
         (\Psi; \tackon{\Theta}
            {y{:}\istrue{\susp{{\sf eval}\,\lf{e}\,\lf{d}}}})$,
\\ then 
   $T = \left(T'; \trstep{y}{{\sf gen/eval}\,\lf{\it tp}\,\lf{d}\,\lf{e}\,
                                  (\tfuser{x'}{\tbangr{N}})}\right)$,
\\ where
   $\Psi \vdash_{\siggendests} N : {{\sf of}\,\lf{e}\,\lf{\it tp}}$ 
\medskip
\item If 
   $T :: (\cdot; x{:}\istrue{\susp{{\sf gen}\,\lf{{\it tp}_0}\,\lf{d_0}}})
         \leadsto^*_{\siggendests}
         (\Psi; \tackon{\Theta}
            {y_1{:}\istrue{\susp{{\sf gen}\,\lf{{\it tp}}\,\lf{d}}}, ~
             y_2{:}\istrue{\susp{{\sf cont}\,\lf{f}\,\lf{d}\,\lf{d'}}}})$,
\\ then 
   $T = \left(T'; \trstep{\lf{d'},y_1,y_2}
              {{\sf gen/cont}\,\lf{\it tp}\,\lf{d}\,\lf{f}\,\lf{{\it tp}'}\,
                (\tfuser{x'}{\tbangr{N}})}\right)$,
\\ where 
   $\Psi \vdash_{\siggendests} N : 
       {{{\sf off}\,\lf{f}\,\lf{{\it tp}'}\,\lf{{\it tp}}}}$.
\medskip
\end{enumerate}
In each instance above, 
$T' :: (\cdot; x{:}\iseph{\susp{{\sf gen}\,\lf{{\it tp}_0}\,\lf{d_0}}})
       \leadsto^*_{\siggendests}
       (\Psi'; \tackon{\Theta}
          {x'{:}\istrue{\susp{{\sf gen}\,\lf{\it tp}\,\lf{d}}}})$,
%
where the variables $x$ and $x'$ may or may not
be the same. (They are the same iff $T' = \emptytrace$, and if they
are the same that implies that 
$\lf{d_0} = \lf{d}$ and $\lf{{\it tp}_0} = \lf{\it tp}$.)
\end{lemma}

Inversion for the generative signature in
Figure~\ref{fig:gen-destinations} has one complication in particular: 
we've broken one of our cardinal rules: the step we are interested in 
isolating may introduce destinations of its own (part 2 of the lemma above).
Therefore, if we are in a situation where 
\[
T = \left(T''; ~~ \trstep{\lf{d'},y_1,y_2}
              {{\sf gen/cont}\,\lf{\it tp}\,\lf{d}\,\lf{f}\,\lf{{\it tp}'}\,
                (\tfuser{x'}{\tbangr{N}})}; ~~ S\right)
\]
how do we know that $\lf{d'} \in {^\bullet}S$? The answer comes in two parts.
First, second position of 
${\sf gen}\,\lf{\it tp}\,\lf{d}$ is a unique index. 

\section{Persistent continuations}
\label{sec:gen-letcc}

\begin{figure}[tp]
\fvset{fontsize=\small,boxwidth=229pt}
\VerbatimInput{sls/gen-destinations2.sls} 
\caption{Generative invariant: destination-passing (alternate version)}
\label{fig:gen-destinations2} 
\end{figure}


\begin{figure}[tp]
\fvset{fontsize=\small,boxwidth=229pt}
\VerbatimInput{sls/gen-letcc.sls} 
\caption{Generative invariant: well-formed first-class continuations}
\label{fig:gen-letcc} 
\end{figure}

\begin{figure}[tp]
\fvset{fontsize=\small,boxwidth=229pt}
\VerbatimInput{sls/gen-letcctp.sls} 
\caption{Generative invariant: well-typed first-class continuations}
\label{fig:gen-letcc} 
\end{figure}


\section{Counting invariants}
\label{sec:gen-count}

Parity:
\fvset{fontsize=\small,boxwidth=229pt}
\VerbatimInput{sls/gen-parity.sls} 

\bigskip
\noindent
Counting:
\fvset{fontsize=\small,boxwidth=229pt}
\VerbatimInput{sls/gen-count.sls} 



% \subsection{Parity}

% \subsection{}

% \subsection{Pointer inequality}
\label{sec:pointer-inequality}
