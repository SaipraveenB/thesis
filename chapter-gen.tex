\chapter{Generative invariants}
\label{chapter-gen}

So far in this thesis, we have presented \sls~and focused on its
concurrent fragment primarily as a way of presenting transition
systems. This view focuses on synthetic transitions as a way of
relating process states. This chapter will focus on another view of
concurrent \sls~specifications as {\it grammars} for describing
well-formed process states. This view was presented previously in the
discussions of adequacy in Section~\ref{sec:framework-reggenworld} and
in Section~\ref{sec:nat-ssos-adequacy}. 

The grammar-like specifications that describe well-formed process
states are called {\it generative signatures}, and generative
signatures can be used to specify sets of process states, or {\it
  worlds}. By the analogy with grammars, we could also describe worlds
as {\it languages} of process states recognized by the grammar. In our
previous discussions of adequacy in
Section~\ref{sec:framework-reggenworld} and in
Section~\ref{sec:nat-ssos-adequacy}, the relevant world was a set of
process states that we could put in bijective correspondence with the
states of an abstract machine.

Our primary use of generative specifications in this thesis is showing
that, under some generative signature $\Sigma_{\it Gen}$ that defines
a world $\mathcal W$, whenever $(\Psi; \Delta) \in \mathcal W$ and
$(\Psi; \Delta) \leadsto_\Sigma (\Psi'; \Delta')$ it is always the
case that $(\Psi'; \Delta') \in \mathcal W$.  (The signature $\Sigma$
that allows the step to happen is some other signature that describes
the transition system we are interested in.)  In such a case, the
world or language defined of well-formed process states is called a
{\it generative invariant} of $\Sigma$.

\subsection*{Type preservation}

The purpose of this chapter is to demonstrate that generative
invariants are a reasonable way of talking about invariants of
\sls~specifications, especially well-formedness and well-typedness
invariants of substructural operational semantics specifications like
the ones presented in Part II. Well-formedness invariants are
important parts of discussions of adequacy, as we have already
seen. Well-typedness invariants are important because they allow us to
prove {\it language safety}, the property (discussed way back in the
introduction) that a language specification is completely free
from undefined behavior.

We don't generally expect all syntactically well-formed expressions
$\obj{e}$ to be free of undefined behavior. When we want to prove
safety for a small-step SOS specification like $\obj{e \mapsto e'}$
from Section~\ref{sec:evaluationcontexts} and the beginning of
Chapter~\ref{chapter-absmachine}, we also define a judgment
$\obj{x_1{:}{\it tp_1},\ldots, x_n{:}{\it tp_n} \vdash e : {\it tp}}$.
This {\it typing judgment} expresses that $\obj{e}$ has type $\obj{\it
  tp}$ if the expression variables $\obj{x_1, \ldots, x_n}$ are
respectively assumed to have the types $\obj{\it tp_1, \ldots,
  tp_n}$. (Note that $\obj{\it tp}$ is an {\it object-level type} as
described in Section~\ref{sec:gen-ordertp}, not an LF type $\tau$ from
Chapter~\ref{chapter-framework}.) Using the typing judgment, we can
prove the safety theorem -- all well typed expressions are free
from undefined behavior -- by way of two theorems. The first theorem is
{\it preservation}: if $\obj{\cdot \vdash e : {\it tp}}$ and $\obj{e \mapsto
  e'}$ then $\obj{\cdot \vdash e' : {\it tp}}$. The second theorem is {\it
  progress}: if $\obj{\cdot \vdash e : {\it tp}}$, then either there is some
$\obj{e'}$ such that $\obj{e \mapsto e'}$ or else $\obj{e}$ is already
a value. 

In SSOS specifications, generative specifications are analogous to
typing judgments, and establishing a generative invariant is analogous
to proving a preservation theorem. Progress theorems for SSOS
specifications will be discussed in Chapter~\ref{chapter-safety}.
This argument forms the centerpiece of the third refinement of our
central thesis:

\smallskip
\begin{quote} 
  {\bf Thesis (Part III):} {\it The \sls~specification of the operational
    semantics of a programming language is a suitable basis for formal
    reasoning about the properties of the language.}
\end{quote} 


\subsection*{Overview}

In Section~\ref{sec:gen-worlds} we review how generative
signatures define a world and show how {\it regular worlds} that
Sch\"urmann implemented in Twelf \cite{schurmann00automating} fall out
as a special case of the worlds described by generative signatures.
We will then discuss invariants of operationalized ordered abstract
machines more generally (Section~\ref{sec:gen-order}), and extend that
discussion from well-{\it formed} process states to well-{\it typed}
process states in Section~\ref{sec:gen-ordertp}.  This is not a large
technical shift, but conceptually it is an important step from
thinking about adequacy-like properties to thinking about preservation
theorems. In Section~\ref{sec:gen-state} we describe how generative
invariants can be established for the sorts of stateful signatures
considered in Section~\ref{sec:richer-ordered-abstract}. In
Section~\ref{sec:gen-destinations} we consider invariants for
specifications in the image of the destination-adding transformation
from Chapter~\ref{chapter-destinations}.
In Section~\ref{sec:gen-letcc} we consider the peculiar case of
first-class continuations, which require us to use persistent
continuation frames. Finally, in Section~\ref{sec:gen-count} we
introduce a more complicated class of generative invariants that
capture the numerical properties of specifications that appear in the
\sls~encoding of voting and auction protocols.

\section{Worlds}
\label{sec:gen-worlds}

{\it Worlds} are nothing more or less than sets of process states
$(\Psi; \Delta)$ -- in the discussion here, we will specifically
exclude process states $(\Psi; \Delta)_{\lf\sigma}$ with a non-empty
accompanying substitution $\lf\sigma$.\footnote{These accompanying
  substitutions were presented in
  Section~\ref{sec:sls-processstates}.}

A world is described by the combination of an initial process state
and generative signature. We semi-formally define a generative
signature as follows:

\bigskip
\begin{definition}\label{def:gensig}
  A {\em generative signature} is one where the ordered, linear, and
  persistent atomic propositions can be separated into two sets -- the
  {\em terminals} and the {\em nonterminals}. Synthetic transitions
  enabled by a generative signature only consume (or reference) 
  terminals and LF terms, but their output variables can include
  LF variables, variables associated with terminals, and variables
  associated with nonterminals.
\end{definition}
\bigskip

\noindent
A generative signature describes a world with the help of the
restriction operator $\restrictsig{(\Psi; \Delta)}{\Sigma}$ introduced
in Section~\ref{sec:framework-restriction}. If $(\Psi; \Delta)$ is
well-defined under the generative signature $\Sigma_{\it Gen}$, and
$\Sigma$ is any signature that includes all of the generative
signature's terminals (and all of its LF bits) but none of its
nonterminals, then $\restrictsig{(\Psi; \Delta)}{\Sigma}$ is only
defined when the only remaining nonterminals in $\Delta$ are
persistent and can be filtered out of $\Delta$. (As long as
$\Sigma_{\it Gen}$ and $\Sigma$ have the same LF declarations, the LF
context $\Psi$ won't have anything filtered out.) When the
classification of terminals and nonterminals is clear, we will leave
off the restricting signature and just write $\restrictsig{(\Psi;
  \Delta)}{}$.

Definition~\ref{def:gensig} is intentionally quite broad -- it need
not even be decidable whether a process state belongs to the world or
language defined by a generative signature need not be
decidable.\footnote{Proof: consider the initial state
  $(x{:}\istrue{\susp{\sf gen}})$ and the rule $\forall
  \lf{e}.\,\forall\lf{v}.\,{\sf gen} \fuse {!}({\sf
    ev}\,\lf{e}\,\lf{v}) \lefti \{ {\sf terminating}\,\lf{e} \}$. The
  predicate ${\sf gen}$ is a nonterminal, the predicate ${\sf
    terminating}$ is a terminal, and ${\sf ev}$ is the encoding of
  big-step evaluation $\obj{e \Downarrow v}$ from
  Figure~\ref{fig:example-transform-cbv}.  The language described is
  isomorphic to the set of terminating $\lambda$-calculus expressions,
  and membership in that set is undecidable.} Future tractable
analyses will therefore presumably be based upon further restrictions
of the very general Definition~\ref{def:gensig}.  Context-free
grammars are one obvious specialization of generative signatures; we
used this correspondence as an intuitive guide in
Section~\ref{sec:framework-reggenworld}.  Perhaps less obviously,
the regular worlds of Twelf \cite{schurmann00automating} are another
specialization of generative signatures.


\subsection{Regular worlds}
\label{sec:gen-regularworlds}

The
regular world specifications used in Twelf
\cite{schurmann00automating} are made up of {\it blocks}. A block
describes a little piece of an LF context, and is declared in the LF
signature as follows:
\[
 {\sf blockname} :
 {\sf some}~\{\lf{a_1}{:}\tau_1\}\ldots\{\lf{a_n}{:}\tau_n\}
~{\sf block}~\{\lf{b_1}{:}\tau'_1\}\ldots\{\lf{b_m}{:}\tau'_m\}
\]
A block declaration is well formed in the signature $\Sigma$ if 
$\left(\lf{a_1}{:}\tau_1,\ldots,\lf{a_{i-1}}{:} \tau_{i-1} \right)\vdash_\Sigma
\tau_i \,{\sf type}$ for $1 \leq i \leq n$ and if 
$\left(\lf{a_1}{:}\tau_1,\ldots,\lf{a_{n}}{:} \tau_{n},
 \lf{b_1}{:}\tau'_1,\ldots,\lf{b_{j-1}}{:}\tau'_{j-1}\right) \vdash_\Sigma
\tau_j \,{\sf type}$ for $1 \leq j \leq m$. 

The first list of LF variable bindings
$\{\lf{a_1}{:}\tau_1\}\ldots\{\lf{a_n}{:}\tau_n\}$ that 
come after the ${\sf some}$ keyword describe the types
of concrete LF terms that must exist for the block to be well formed.
The second list of LF variable bindings represents the bindings that
the block actually adds to the LF context. The regular worlds of 
Twelf are defined as sets of block identifiers 
$({\sf block1} \mid \ldots \mid {\sf blockn})$. A set of block identifiers
and a Twelf signature $\Sigma$ define a world as follows: if
\smallskip
\begin{itemize}
\item $\Psi$ is a well-formed
LF context in the current world, 
\item ${\sf blockname} :
 {\sf some}~\{\lf{a_1}{:}\tau_1\}\ldots\{\lf{a_n}{:}\tau_n\}
~{\sf block}~\{\lf{b_1}{:}\tau'_1\}\ldots\{\lf{b_m}{:}\tau'_m\} \in \Sigma$
 is one of the blocks in the current world, and
\item there is a $\lf{\sigma}$ such that
$\Psi \vdash_\Sigma \lf{\sigma} :
\lf{a_1}{:}\tau_1,\ldots,\lf{a_n}{:}\tau_n$, 
\end{itemize}
\smallskip then $\Psi, \lf{b_1}{:}\lf\sigma\tau'_1,\ldots,
\lf{b_m}{:}\lf\sigma\tau'_m$ is also a well-formed LF context in the
current world. The {\it closed world}, which contains only the empty
process state, is a subset of every regular world, so this definition
gives us the rules for generating a world -- a set of contexts -- from
a series of block declarations.

One simple example of a regular world (previously discussed in
Section~\ref{sec:framework-reggenworld}) is the world that just
contains arbitrary expression variables with LF type ${\sf exp}$. This
world can be described with the block ${\sf blockexp}$:
\[
 {\sf blockexp} : 
 {\sf some}
~{\sf block}~\{{\lf x}{:}{\sf exp}\}
\]
If we had a judgment ${\sf natvar}\,\lf{x}\,\lf{n}$ that associated
every LF variable $\lf{x}{:}{\sf exp}$ with some natural number
$\lf{n}{:}{\sf nat}$, then in order to make sure that every expression
variable was associated with some natural number we would use this
world:
\[
 {\sf blocknatvar} : 
 {\sf some}~\{{\lf n}{:}{\sf nat}\}
~{\sf block}~\{{\lf x}{:}{\sf exp}\}~
               \{\lf{\it nv}{:}{\sf natvar}\,\lf{x}\,\lf{n}\}
\]
The world described by the combination of ${\sf blockexp}$ and ${\sf
  blocknatvar}$ is one where every LF variable $\lf{x}{:}{\sf exp}$
is associated with either zero or one LF variables of type ${\sf
  natvar}\,\lf{x}\,\lf{n}$. Assuming that there are no constants of
type ${\sf natvar}$, a property we can easily enforce with subordination, this
gives us a uniqueness property: if ${\sf natvar}\,\lf{x}\,\lf{n}$ and
${\sf natvar}\,\lf{x}\,\lf{m}$, then $\lf{m} = \lf{n}$. 

\subsection{Regular worlds from generative signatures}

A block declaration ${\sf blockname} :
 {\sf some}~\{\lf{a_1}{:}\tau_1\}\ldots\{\lf{a_n}{:}\tau_n\}
~{\sf block}~\{\lf{b_1}{:}\tau'_1\}\ldots\{\lf{b_m}{:}\tau'_m\}$ can
be described by one rule in a generative signature:
\begin{align*}
&{\sf blockname} : 
  \forall \lf{a_1}{:}\tau_1\ldots \forall\lf{a_n}{:}\tau_n.\,
  \{ \exists \lf{b_1}{:}\tau'_1 \ldots \lf{b_m}{:}\tau'_m.\,
     \one
  \}
\intertext{Because a regular world is just a set of blocks, 
the generative signature corresponding
to a regular world contains one rule for each block in the regular
worlds description.
The world $({\sf blockexp} \mid {\sf blockvar})$ corresponds
to the following generative signature:}
&{\sf nat} : {\sf type}, 
\\
&\mbox{\it \ldots declare constants of type ${\sf nat}$ \ldots }
\\
&{\sf exp} : {\sf type}, 
\\
&\mbox{\it \ldots declare constants of type ${\sf exp}$ \ldots }
\\
&{\sf blockexp} : 
  \{ \exists \lf{x}{:}{\sf exp}.\,\one\},
\\
&{\sf blocknatvar} : \forall \lf{n}{:}{\sf nat}.\,
  \{ \exists \lf{x}{:}{\sf exp}.\,
     \exists \lf{\it nv}{:}{\sf natvar}\,\lf{x}\,\lf{n}.\, \one \}
\end{align*}
Call this regular world signature $\Sigma_{\it RW}$. It is an extremely
simple example of a generative signature -- there are no
terminals and no nonterminals -- so the restriction operator has
no effect. The world described by $({\sf blockexp} \mid {\sf blocknatvar})$
is identical to the set of LF contexts $\Psi$ such that
$(\cdot; \cdot) \leadsto_{\Sigma_{RW}} (\Psi; \cdot)$.

\subsection{Regular worlds in substructural specifications}

From the structure of translated LF regular worlds, it is hopefully
apparent that by replacing the proposition $\one$ in the heads of the
generative ${\sf block*}$ rules with more interesting positive
\sls~propositions,  we can extend the language of regular
worlds to allow the introduction of ordered, linear, and persistent
\sls~propositions as well. For instance, the rule
${\sf blockitem} : 
\forall \lf{n}. \, \{ {\sf item}\,\lf{n} \}$,
where ${\sf item}$ is a linear predicate,
describes the world of contexts that take the form
$\left(\cdot; ~ x_1{:}\iseph{\susp{{\sf item}\,\lf{n_1}}}, ~
         \ldots, ~
         x_k{:}\iseph{\susp{{\sf item}\,\lf{n_k}}}\right)$
for some numbers $\lf{n_1}\ldots\lf{n_k}$. 
The world described by this generative signature is an invariant of a
rule like
\begin{align*}
  {\sf merge} : 
  \forall \lf{n}.\,\forall\lf{m}.\,\forall\lf{p}.\,
   {\sf item}\,\lf{n} \fuse
   {\sf item}\,\lf{m} \fuse
   {!}({\sf plus}\,\lf{n}\,\lf{m}\,\lf{p}) 
    \lefti \{ {\sf item}\,\lf{p} \}
\end{align*}
that combines two items,
where ${\sf plus}$ is  negative predicate defined with a deductive
specification in 
Figure~\ref{fig:plus}.  

Such substructural generalizations of regular worlds are sufficient
for the encoding of stores in Linear LF \cite{cervesato02linear} and
stacks in Ordered LF \cite{polakow01ordered}. They also suffice
to describe well-formedness invariants in Felty and Momigliano's
sequential specifications \cite{felty12hybrid}. However, regular
worlds are insufficient for all the
invariants discussed in the remainder of this chapter.

\subsection{Generative versus consumptive signatures}

The use of regular worlds helps explain why generative signatures are
{\it generative}. A earlier version of the results in this chapter and
the next used {\it consumptive} signatures
\cite{simmons10type}. Consumptive signatures are basically generative
signatures with the arrows turned around: we consume well-formed
contexts using consumptive rules like $\forall\lf{e}.\,{\sf
  eval}\,\lf{e} \lefti \{ {\sf gen} \}$ and $\forall \lf{f}.\,{\sf
  gen} \fuse {\sf cont}\,\lf{f} \lefti \{ {\sf gen} \}$ instead of
using generative 
rules like $\forall\lf{e}.\,{\sf gen}\lefti \{ {\sf eval}\,\lf{e} \}$
and $\forall \lf{f}.\,{\sf gen} \lefti \{ {\sf gen} \fuse {\sf
  cont}\,\lf{f} \}$. 

There is a bit of a conceptual advantage to using consumptive
signatures $\Sigma$, because we can describe the set of process states
$(\Psi; \Delta)$ where $\Psi; \Delta \vdash \islax{{\sf gen}}$ rather
than the set of process states where $(\cdot; x{:}\istrue{\susp{\sf
    gen}}) \leadsto^* (\Psi; \Delta)$.\footnote{As long as $\Psi$ and
  $\Delta$ contain only nonterminals -- using consumptive signatures
  doesn't obviate the need for the restriction operation
  $\restrictsig{(\Psi; \Delta)}{}$ or some equivalent restriction
  operation.}  Working with complete derivations instead of traces is
familiar, but it does not especially simplify any of the proofs in
\cite{simmons10type}.  Therefore, for for purely
context-free-grammar-like invariants, such as the PDA invariant from
Section~\ref{sec:framework-reggenworld} and the SSOS invariant from
Section~\ref{sec:nat-ssos-adequacy}, generative and consumptive
signatures are effectively equivalent.

However, for generative signatures describing regular worlds, there is
no notion of turning the arrows around to get an appropriate
consumptive signature. In particular, say
we want to treat 
\begin{align*}
\Psi_{\it good} & = 
 \left(
 \lf{x_1}{:}{\sf exp}, \lf{{\it nv}_1}{:}{\sf natvar}\,\lf{x_1}\,\lf{n_1},
 \lf{x_2}{:}{\sf exp}, \lf{{\it nv}_2}{:}{\sf natvar}\,\lf{x_2}\,\lf{n_2}
 \right)
\intertext{as a well-formed LF context but {\it not} treat }
\Psi_{\it bad} & = 
 \left(
 \lf{x}{:}{\sf exp}, \lf{{\it nv}_1}{:}{\sf natvar}\,\lf{x}\,\lf{n_1},
  \lf{{\it nv}_2}{:}{\sf natvar}\,\lf{x}\,\lf{n_2}
 \right)
\end{align*} as well-formed. It is trivial to use Twelf's regular
worlds or generative signatures to impose this condition, but it does
not seem possible to use consumptive signatures for this
purpose. There exists a substitution \mbox{$\lf{(x/\!\!/x_1, {\it
      nv}_1/\!\!/{\it nv}_1, x/\!\!/x_2, {\it nv}_2/\!\!/{\it
      nv}_2)}$} from $\Psi_{\it good}$ to $\Psi_{\it bad}$; therefore,
by variable substitution (Theorem~\ref{thm:varsubst}), if there exists
a derivation of $\Psi_{\it good} \vdash_\Sigma \islax{\sf gen}$ there
also exists a derivation of $\Psi_{\it bad} \vdash_\Sigma \islax{\sf
  gen}$. This means that consumptive signatures as presented in
\cite{simmons10type} cannot describe the (regular) world that includes
$\Psi_{\it good}$ and rejects $\Psi_{\it bad}$. This is related to the
issues of variable and pointer equality discussed in
Section~\ref{sec:mutable-storage}.

The generative signatures used to describe state in
Section~\ref{sec:gen-state} and destination-passing style in
Section~\ref{sec:gen-destinations} rely critically on the
regular-worlds-like uniqueness invariants that are provided by
generative signatures and not by consumptive signatures. (The progress
and preservation proofs in \cite{simmons10type} consider neither
mutable state nor destination-passing style.)

\section{Invariants of ordered specifications}
\label{sec:gen-order}

We already covered applications of generative invariants for ordered
abstract machine SSOS specifications in
Section~\ref{sec:nat-ssos-adequacy}. In this section, we will discuss
a generalization of that generative invariant to abstract machines
with parallel evaluation and recoverable failure.


\begin{figure}[t]
\fvset{fontsize=\small,boxwidth=229pt}
\VerbatimInput{sls/gen-order-prog.sls}
\caption{Ordered abstract machine with parallel evaluation and failure}
\label{fig:gen-order-prog}
\end{figure}

In Figure~\ref{fig:gen-order-prog} we describe a flat ordered abstract
machine with parallel features (parallel evaluation of the function
and argument in an application, as discussed in
Section~\ref{sec:trans-par} and Figure~\ref{fig:cbv-ev-ssos-par}) and
recoverable failure (as presented in Section~\ref{sec:failure} and
Figure~\ref{fig:ssos-fail}). To make sure there is still an
interesting sequential feature -- specifically, to demonstrate the use
of ${\sf cont}$ frames -- we also introduce a let-expression
$\interp{{\sf let}\,x = e\,{\sf in}\,e'} = \lf{{\sf
    let}\,\interp{e}\,\lambda x.\interp{e'}}$. The particular features
are less important than the general setup, which effectively
represents all the specifications from
Chapter~\ref{chapter-absmachine} that used only ordered atomic
propositions.


Our goal is to describe a generative signature that represents the
well-formed process states of the specification in
Figure~\ref{fig:gen-order-prog}. What determines whether a process
state is well formed? The intended adequacy theorem was our guide in
Section~\ref{sec:nat-ssos-adequacy}, and the intended progress theorem
will guide our hand in Section~\ref{sec:gen-ordertp}. In this case,
our goal is that every well-formed state should be {\it
  reachable}. That is, if $(x{:}\istrue{\susp{\sf gen}})
\leadsto^* \Delta$ and if $\Delta$ contains no
instances of ${\sf gen}$, then there should be an expression $\obj{e}$
such that $(x{:}\istrue{\susp{{\sf eval}\,\interp{e}}}) \leadsto^*
\Delta$ under the signature from
Figure~\ref{fig:gen-order-prog}. (Because ${\sf gen}$ is the only
nonterminal, we can express that $\Delta$ contains no instances of
${\sf gen}$ with the restriction operator, writing
$\restrictsig{\Delta}{}$.) We will discuss the proof of this property
in Section~\ref{sec:well-formed-reachable}.

The analogues of the unary grammar productions, associated with the
terminals ${\sf eval}\,\lf{e}$, ${\sf retn}\,\lf{v}$, and ${\sf
  error}$, are straightforward:
%
\smallskip
\fvset{fontsize=\small,boxwidth=229pt}
\VerbatimInput{sls/gen-order-core.sls} 
\smallskip 
%
As in Section~\ref{sec:nat-ssos-adequacy}, we use a
deductively-defined judgment ${\sf value}\,\lf{v}$ to stipulate that
we only return values. The process state $(y{:}\istrue{\susp{{\sf
      retn}\,\interp{e_1\,e_2}}})$ is not well formed: the
application expression $\obj{e_1\,e_2}$ is not a value, and
there is no $\obj{e}$ such that $(x{:}\istrue{\susp{{\sf
      eval}\,\interp{e}}}) \leadsto^* (y{:}\istrue{\susp{{\sf
      retn}\,\interp{e_1\,e_2}}})$ under the signature from
Figure~\ref{fig:gen-order-prog}.

There is a potential catch when we consider the rules for sequential
continuations ${\sf cont}\,\lf{f}$ and parallel continuations ${\sf
  cont2}\,\lf{f}$. We expect a sequential continuation frame to be
preceded by a single well-formed computation, and for a parallel
continuation frame to be preceded by {\it two} well-formed
computations, suggesting these rules:
%
\smallskip
\fvset{fontsize=\small,boxwidth=229pt}
\VerbatimInput{sls/gen-order-bad.sls} 
\smallskip 
%
Even though ${\sf gen/cont}$ is exactly the rule for sequential
continuations in Section~\ref{sec:nat-ssos-adequacy}, it does not work
here.  Both parallel and sequential continuations are indexed by
frames, but the parallel frame ${\sf app1}$ cannot appear in a
sequential continuation, nor can the sequential frame $({\sf
  let1}\,\lf{\lambda x.e\,x})$ appear in a parallel frame. 

\begin{figure}[tp]
\fvset{fontsize=\small,boxwidth=229pt}
\VerbatimInput{sls/gen-order.sls} 
\caption{Generative invariant: well-formed process states}
\label{fig:gen-order} 
\end{figure}

\newcommand{\siggenorder}{\Sigma_{\it Gen\ref{fig:gen-order}}}

This is fundamentally no more complicated than the restrictions we
placed on the ${\sf retn}\,\lf{v}$ terminal. All expressions (LF
variables of type ${\sf exp}$) can appear in ${\sf exp}\,\lf{e}$
propositions (and in ${\sf handle}\,\lf{e}$ propositions), but only
some can appear in ${\sf retn}\,\lf{v}$ frames. We describe that
subset of frames with the negative atomic proposition ${\sf
  value}\,\lf{v}$, which is deductively defined. Similarly, only some
frames can appear in ${\sf cont}\,\lf{f}$ terminals, and only some
frames can appear in ${\sf cont2}\,\lf{f}$ terminals. The former subset
can be expressed by a negative atomic proposition ${\sf okf}\,\lf{f}$,
and the latter by a negative atomic proposition ${\sf okf2}\,\lf{f}$.
Both of these are deductively defined.  The full specification of this
generative invariant is shown in Figure~\ref{fig:gen-order}; we will
refer to this generative signature as $\siggenorder$

\subsection{Inversion on the generative signature}

Traditional inversion lemmas are a critical part of preservation
properties for small-step operational semantics specifications. If we
are given that $\obj{e_1\,e_2 \mapsto e_1'\,e_2}$ and also that
$\obj{\cdot \vdash e_1\,e_2 : {\it tp}}$. An inversion lemma proceeds
by case analysis on the structure of the derivation 
$\obj{\cdot \vdash e : {\it tp}}$, and allows us to conclude that
$\obj{\cdot \vdash e_1 : {\it tp'} \Rightarrow {\it tp}}$
and that $\obj{\cdot \vdash e_2 : {\it tp'} }$ for some object-level
type $\obj{\it tp'}$.  In other words, an inversion lemma allows us to 
take knowledge about a term's structure and obtain information about 
the typing derivation's structure. 

Inversion on a generative signature is intuitively similar: we take
information about the structure of a process state and use it to learn
about the generative trace that formed that process state. Inversion
lemmas plays a similar role here to the role they play in SOS accounts
of preservation.

\bigskip
\begin{lemma}[Inversion]~
\begin{enumerate}
\item If 
   $T :: (x{:}\istrue{\susp{\sf gen}}) \leadsto^*_{\siggenorder}
         \tackon{\Theta}{y{:}\istrue{\susp{{\sf eval}\,\lf{e}}}}$,
\\ then 
   $T = \left(T'; \trstep{y}{{\sf gen/eval}\,\lf{e}\,x'}\right)$.
\medskip
\item If 
   $T :: (x{:}\istrue{\susp{\sf gen}}) \leadsto^*_{\siggenorder}
         \tackon{\Theta}{y{:}\istrue{\susp{{\sf retn}\,\lf{v}}}}$,
\\ then 
   $T = \left(T'; \trstep{y}{{\sf gen/retn}\,\lf{v}\,(\tfuser{x'}{\tbangr{N}})}\right)$,
\\ where 
   $\cdot \vdash_{\siggenorder} N : {{{\sf value}\,\lf{v}}}$.
\medskip
\item If 
   $T :: (x{:}\istrue{\susp{\sf gen}}) \leadsto^*_{\siggenorder}
         \tackon{\Theta}{y_1{:}\istrue{\susp{{\sf gen}}}, ~
                         y_2{:}\istrue{\susp{{\sf cont}\,\lf{f}}}}$,
\\ then 
   $T = \left(T'; \trstep{y_1,y_2}{{\sf gen/cont}\,\lf{f}\,(\tfuser{x'}{\tbangr{N}})}\right)$,
\\ where 
   $\cdot \vdash_{\siggenorder} N : {{{\sf okf}\,\lf{f}}}$.
\medskip
\item If
   $T :: (x{:}\istrue{\susp{\sf gen}}) \leadsto^*_{\siggenorder}
         \tackon{\Theta}{y_1{:}\istrue{\susp{{\sf gen}}}, ~
                         y_2{:}\istrue{\susp{{\sf gen}}}, ~
                         y_3{:}\istrue{\susp{{\sf cont2}\,\lf{f}}}}$,
\\ then 
   $T = \left(T'; \trstep{y_1,y_2,y_3}{{\sf gen/cont2}\,\lf{f}\,(\tfuser{x'}{\tbangr{N}})}\right)$,
\\ where 
   $\cdot \vdash_{\siggenorder} N : {{{\sf okf2}\,\lf{f}}}$.
\medskip
\item If 
   $T :: (x{:}\istrue{\susp{\sf gen}}) \leadsto^*_{\siggenorder}
         \tackon{\Theta}{y{:}\istrue{\susp{{\sf error}}}}$,
\\ then 
   $T = \left(T'; \trstep{y}{{\sf gen/error}\,x'}\right)$.
\medskip
\item If 
   $T :: (x{:}\istrue{\susp{\sf gen}}) \leadsto^*_{\siggenorder}
         \tackon{\Theta}{y_1{:}\istrue{\susp{{\sf gen}}}, ~
                         y_2{:}\istrue{\susp{{\sf handle}\,\lf{e}}}}$,
\\ then 
   $T = \left(T'; \trstep{y_1,y_2}{{\sf gen/handle}\,\lf{e}\,(\tfuser{x'}{\tbangr{N}})}\right)$.
\medskip
\end{enumerate}
In each instance above, 
$T' :: (x{:}\istrue{\susp{\sf gen}}) \leadsto^*_{\siggenorder}
          \tackon{\Theta}{x'{:}\istrue{\susp{{\sf gen}}}}$,
where the variables $x$ and $x'$ may or may not
be the same. (They are the same iff $T' = \emptytrace$.)
\end{lemma}

\begin{proof}
  Each case follows by induction and case analysis on the last steps
  of $T$.  In each case, we know that the trace cannot be empty,
  because the variable bindings $y{:}\istrue{\susp{{\sf
        eval}\,\lf{e}}}$, $y{:}\istrue{\susp{{\sf retn}\,\lf{v}}}$,
  $y_2{:}\istrue{\susp{{\sf cont}\,\lf{f}}}$,
  $y_3{:}\istrue{\susp{{\sf cont2}\,f}}$, $y{:}\istrue{\susp{{\sf
        error}}}$, and $y_2{:}\istrue{\susp{{\sf handle}\,\lf{e}}}$,
  respectively, appear in the final process state but not the initial
  process state but not in the initial process state. Therefore, $T =
  T''; S$ for some $T''$ and $S$.  Let $V$ be the set of relevant
  variables -- $\{y\}$ in parts 1, 2, and 5, $\{y_1, y_2\}$ in parts 3
  and 6, and $\{y_1,y_2,y_3\}$ in part 4. Either the output variables
  of $S$ (written $S^{\bullet}$) are disjoint from $V$ or not.

  If $\emptyset = S^{\bullet} \cap V$, then we call the induction
  hypothesis to get that $T'' = T'''; S'$, where $S' = \trstep{y}{{\sf
      gen/eval}\,\lf{e}\,x'}$ in part 1, $S' = \trstep{y}{{\sf
      gen/retn}\,\lf{v}\,(\tfuser{x'}{\tbangr{N}})}$ in part 2, and so
  on.  In each of the six parts, $S'{^\bullet} = V$ contains no
  variables associated with persistent propositions or LF
  variables. These variables persist to the final process state and
  therefore cannot be consumed by $S$. This means that $\left(T''';
    S'; S\right) = \left(T'''; S; S'\right)$, and we can conclude
  letting $T' = \left(T''; S\right)$

  If $\emptyset \neq S^{\bullet} \cap V$, then the proof only works if
  we can let $T' = T''$ and immediately succeed. This is
  straightforward in cases 1, 2, and 5 where $V$ is a singleton
  set. In case 3, we have to observe that, if the variable bindings
  $y_1{:}\istrue{\susp{{\sf gen}}}$ and $y_2{:}\istrue{\susp{{\sf
        cont}\,\lf{f}}}$ appear in order in the substructural context,
  there is no step in the signature $\siggenorder$ that has $y_1$
  among its output variables that does not also have $y_2$ among its
  output variables. (This property would not continue to hold if there
  was a rule like ${\sf gen} \lefti \{ {\sf gen} \}$ in $\Sigma_{\it
    Gen\ref{fig:gen-order}}$.) Therefore, in part 3, the last step must have the form
  $\trstep{y_1, y_2}{{\sf gen/cont}\,\lf{f}\,V}$ where $\cdot
  \vdash_{\siggenorder} V : \left({\sf gen} \fuse {!}({{\sf
        okf}\,\lf{f}})\right)$. We get an $N$ such that $V =
  \tfuser{x'}{\tbangr{N}}$ and $\cdot \vdash_{\siggenorder} N :
  {{{\sf okf}\,\lf{f}}}$ by traditional type inversion
  on the structure of $V$.
\end{proof}

\subsection{Preservation of the generative invariant}

\begin{theorem}[$\siggenorder$ is a generative invariant]
If $T_1 :: (x{:}\istrue{\susp{\sf gen}}) \leadsto^*_{\siggenorder} 
   \Delta$ and $S :: \restrictsig{\Delta}{} \leadsto \Delta'$
under the signature from Figure~\ref{fig:gen-order-prog}, then
$T_2 :: (x{:}\istrue{\susp{\sf gen}}) \leadsto^*_{\siggenorder} 
   \Delta$
\end{theorem}

\begin{proof} As in the proofs of Theorem~\ref{thm:pda-preservation}
  and Theorem~\ref{thm:adequate-pres}, we enumerate the synthetic
  transitions possible under the signature in
  Figure~\ref{fig-gen-order-prog}, perform inversion on the structure
  of $T_1$, and then use the results of inversion to construct
  $T_2$. We give three illustrative cases corresponding to the
  fragment dealing with functions and parallel application.

\begin{description}
%%%%%%%%
%%%%%%%%
%%%%%%%%
\item 
  [Case $\trstep{y}{{\sf ev/lam}\,\lf{(\lambda x. e)}\,x}
   ::
   \tackon{\Theta}
     {x{:}\istrue{\susp{{\sf eval}\,\lf{({\sf lam}\,\lambda x.e)}}}}
   \leadsto
   \tackon{\Theta}
     {y{:}\istrue{\susp{{\sf retn}\,\lf{({\sf lam}\,\lambda x.e)}}}}$]~

\medskip
Applying inversion (Part 1) to $T_1$, we have 

\begin{tabbing}
$T_1 = ~$ \= \qquad \= $(x{:}\istrue{\susp{\sf gen}})$
\\
\>$T'$
\\
\>\>$\tackon{\Theta}{x'{:}\istrue{\susp{\sf gen}}}$
\\
\>$\trstep{x}{{\sf gen/eval}\,\lf{({\sf lam}\,\lambda x.e)}\,x'}$
\\
\>\>$\tackon{\Theta}
       {x{:}\istrue{\susp{{\sf eval}\,\lf{({\sf lam}\,\lambda x.e)}}}}$
\end{tabbing}

We can use $T'$ to construct $T_2$ as follows:

\begin{tabbing}
$T_2 = ~$ \= \qquad \= $(x{:}\istrue{\susp{\sf gen}})$
\\
\>$T'$
\\
\>\>$\tackon{\Theta}{x'{:}\istrue{\susp{\sf gen}}}$
\\
\>$\trstep{y}{{\sf gen/retn}\,\lf{({\sf lam}\,\lambda x.e)}\,(\tfuser{x'}{\tbangr{({\sf value/lam}\,\lf{(\lambda x.e)})}})}$
\\
\>\>$\tackon{\Theta}
     {y{:}\istrue{\susp{{\sf retn}\,\lf{({\sf lam}\,\lambda x.e)}}}}$
\end{tabbing}

%%%%%%%%
%%%%%%%%
%%%%%%%%
\item 
  [Case $\trstep{y}{{\sf ev/app}\,\lf{e_1}\,\lf{e_2}\,x}$]~

\qquad
  $::
   \tackon{\Theta}
     {x{:}\istrue{\susp{{\sf eval}\,\lf{({\sf app}\,e_1\,e_2)}}}}$

\qquad\qquad
  $\leadsto
   \tackon{\Theta}
     {y_1{:}\istrue{\susp{{\sf eval}\,\lf{e_1}}}, ~
      y_2{:}\istrue{\susp{{\sf eval}\,\lf{e_2}}}, ~
      y_3{:}\istrue{\susp{{\sf cont2}\,\lf{\sf app1}}}}$
\medskip

Applying inversion (Part 1) to $T_1$, we have 

\begin{tabbing}
$T_1 = ~$ \= \qquad \= $(x{:}\istrue{\susp{\sf gen}})$
\\
\>$T'$
\\
\>\>$\tackon{\Theta}{x'{:}\istrue{\susp{\sf gen}}}$
\\
\>$\trstep{x}{{\sf gen/eval}\,\lf{({\sf app}\,e_1\,e_2)}\,x'}$
\\
\>\>$\tackon{\Theta}{x{:}\istrue{\susp{{\sf eval}\,\lf{({\sf app}\,e_1\,e_2)}}}}$
\end{tabbing}

We can use $T'$ to construct $T_2$ as follows:

\begin{tabbing}
$T_2 = ~$ \= \qquad \= $(x{:}\istrue{\susp{\sf gen}})$
\\
\>$T'$
\\
\>\>$\tackon{\Theta}{x'{:}\istrue{\susp{\sf gen}}}$
\\
\>$\trstep{y_1',y_2',y}{{\sf gen/cont2}\,\lf{{\sf app1}}\,(\tfuser{x'}{\tbangr{{\sf okf2/app1}}})}$
\\
\>$\trstep{y_1}{{\sf gen/eval}\,\lf{e_1}\,y_1'}$
\\
\>$\trstep{y_2}{{\sf gen/eval}\,\lf{e_2}\,y_2'}$
\\
\>\>$\tackon{\Theta}{y{:}\istrue{\susp{{\sf retn}\,\lf{\sf unit}}}}$
\end{tabbing}

%%%%%%%%
%%%%%%%%
%%%%%%%%
\item 
  [Case $\trstep{y}{{\sf ev/app1}\,\lf{(\lambda x.\,e)}\,\lf{v_2}\,x}$]~

\qquad
  $::
   \tackon{\Theta}{x_1{:}\istrue{\susp{{\sf retn}\,\lf{(\lambda x.\,e)}}}, ~
                   x_2{:}\istrue{\susp{{\sf retn}\,\lf{v_2}}}, ~
                   x_3{:}\istrue{\susp{{\sf cont2}\,\lf{\sf app1}}}}$

\qquad\qquad
  $\leadsto
   \tackon{\Theta}{y{:}\istrue{\susp{{\sf eval}\,\lf{([v_2/x]e)}}}}$

\medskip
Applying inversion (Part 2, twice, and then Part 4) to $T_1$, we have

\begin{tabbing}
$T_1 = ~$ \= \qquad \= $(x{:}\istrue{\susp{\sf gen}})$
\\
\>$T'$
\\
\>\>$\tackon{\Theta}{x'{:}\istrue{\susp{\sf gen}}}$
\\
\>$\trstep{x_1', x_2', x_3'}
     {{\sf gen/cont2}\,\lf{\sf app1}\,(\tfuser{x'}{\tbangr{N}})}$
\\
\>$\trstep{x_1}
     {{\sf gen/retn}\,\lf{({\sf lam}\,\lambda x.e)}\,
        (\tfuser{x_1'}{\tbangr{N_1}})}$ 
\\
\>$\trstep{x_2}
     {{\sf gen/retn}\,\lf{v_2}\,(\tfuser{x_2'}{\tbangr{N_2}})}$
\\
\>\>$\tackon{\Theta}{x_1{:}\istrue{\susp{{\sf retn}\,\lf{(\lambda x.\,e)}}}, ~
                   x_2{:}\istrue{\susp{{\sf retn}\,\lf{v_2}}}, ~
                   x_3{:}\istrue{\susp{{\sf cont2}\,\lf{\sf app1}}}}$
\end{tabbing}

We can use $T'$ to construct $T_2$ as follows:
\begin{tabbing}
$T_2 = ~$ \= \qquad \= $(x{:}\istrue{\susp{\sf gen}})$
\\
\>$T'$
\\
\>\>$\tackon{\Theta}{x'{:}\istrue{\susp{\sf gen}}}$
\\
\>$\trstep{y}
     {{\sf gen/eval}\,\lf{([v_2/x]e)}\,x'}$
\\
\>\>$\tackon{\Theta}{y{:}\istrue{\susp{{\sf eval}\,\lf{([v_2/x]e)}}}}$
\end{tabbing}


\end{description}

\noindent
The other cases, corresponding to the rules ${\sf ev/unit}$, ${\sf
  ev/fail}$, ${\sf ev/catch}$, ${\sf ev/catcha}$, ${\sf ev/catchb}$,
${\sf ev/error}$, ${\sf ev/errerr}$, ${\sf ev/errret}$, and ${\sf
  ev/reterr}$ all follow the same lines: enumeration, inversion, and
reconstruction. 
\end{proof}

Note that, in the case corresponding to the rule ${\sf
  ev/app1}$, we obtained but did not use three terms $\cdot \vdash N :
{{\sf okf2}\,\lf{\sf app1}}$, $\cdot \vdash N_1 : {\sf
    value}\,\lf{({\sf lam}\,\lambda x.e)}$, and $\cdot \vdash N_2 :
  {{\sf value}\,\lf{v_2}}$. By traditional inversion, we know
  that $N = {\sf okf2/app1}$ and $N_1 = {\sf value/lam}\,\lf{(\lambda
    x.e)}$, but that was not necessary to this theorem.


\section{From well-formed to well-typed states}
\label{sec:gen-ordertp}

In order to describe those expressions whose evaluations never get
stuck, we introduce object level types $\obj{\it tp}$ and define a
typing judgment $\obj{\Gamma \vdash e : {\it tp}}$.  We encode
object-level types as LF terms classified by the LF type ${\sf
  typ}$. The unit type $\obj{\one} = \lf{\sf unittp}$ classifies units
$\obj{\langle\rangle}$, and the function type $\interp{{\it tp}_1
  \Rightarrow {\it tp}_2} = \lf{\sf arr}\,\interp{{\it
    tp}_1}\,\interp{{\it tp}_2}$ classifies lambda expressions.

\begin{figure}[tp]
\fvset{fontsize=\small,boxwidth=229pt}
\VerbatimInput{sls/gen-order-of.sls} 
\caption{Simple rules for expressions}
\label{fig:gen-order-of} 
\end{figure}

In a syntax-directed type system, each syntactic construct is associated
with a different typing rule.
These are the typing rules necessary for describing the language
constructs in Figure~\ref{fig:gen-order-prog}:
\[
\infer
{\obj{\Gamma \vdash \langle\rangle : \one} \mathstrut}
{\mathstrut}
\qquad
\infer
{\obj{\Gamma \vdash \lambda x.e : {\it tp' \Rightarrow tp}} \mathstrut}
{\obj{\Gamma, x{:}{\it tp'} \vdash e : {\it tp}} \mathstrut}
\qquad
\infer
{\obj{\Gamma \vdash e_1\,e_2 : {\it tp}} \mathstrut}
{\obj{\Gamma \vdash e_1 : {\it tp' \Rightarrow tp}}
 &
 \obj{\Gamma \vdash e_2 : {\it tp'}}
 \mathstrut}
\]
\[
\infer
{\obj{\Gamma \vdash {\sf fail} : {\it tp}} \mathstrut}
{}
\qquad
\infer
{\obj{\Gamma \vdash {\sf try}\,e_1\,{\sf ow}\,e_2 : {\it tp}} \mathstrut}
{\obj{\Gamma \vdash e_1 : {\it tp}} 
 &
 \obj{\Gamma \vdash e_2 : {\it tp}}
 \mathstrut}
\]
We can adequately encode derivations of the judgment
$\obj{x_1{:}{\it tp}_1, \ldots, x_n{:}{\it tp}_n \vdash e : {\it tp}}$ as 
\sls~derivations $\lf{x_1}{:}{\sf exp}, \ldots, \lf{x_n}{:}{\sf exp}; 
y_1 : \ispers{({\sf of}\,\lf{x_1}\,\interp{{\it tp}_1})}, \ldots,
y_n : \ispers{({\sf of}\,\lf{x_1}\,\interp{{\it tp}_n})}
\vdash {\sf of}\,\interp{e}\,\interp{\it tp}$ under the signature
in Figure~\ref{fig:gen-order-of}.

\begin{figure}[tp]
\fvset{fontsize=\small,boxwidth=229pt}
\VerbatimInput{sls/gen-ordertp.sls} 
\caption{Generative invariant: well-typed process states}
\label{fig:gen-ordertp} 
\end{figure}


This typing judgment allows us to describe well-formed initial states,
but it is not sufficient to describe intermediate states. To this end,
we describe typing rules for frames, refining the negative predicates
${\sf okf}\,\lf{f}$ and ${\sf okf2}\,\lf{f}$ from
Figure~\ref{fig:gen-order}. The \sls~proposition describing well-typed
seqential frames is ${\sf off}\,\lf{f}\,\interp{{\it
    tp}'}\,\interp{\it tp}$. This proposition expresses that the frame
$\lf{f}$ {\it expects} a returned result with type $\obj{\it tp'}$ and
{\it produces} a computation with type $\obj{{\it tp}}$.\footnote{The
  judgment we encode in \sls~as $({\sf off}\,\lf{f}\,\interp{{\it
      tp}'}\,\interp{\it tp})$ is written $\obj{f : {\it tp}'
    \Rightarrow {\it tp}}$ in \cite[Chapter 27]{harper12practical}.}
The parallel version is $({\sf off}\,\lf{f}\,\interp{{\it
    tp}_1}\,\interp{{\it tp}_2}\,\interp{\it tp})$, and expects two
subcomputation with types $\obj{{\it tp}_1}$ and $\obj{{\it tp}_2}$,
respectively, in order to produce a computation of type $\obj{{\it
    tp}}$.

\section{State}
\label{sec:gen-state}


% \subsection{Store typing}


% \subsection{Environment semantics}

\section{Destination-passing}
\label{sec:gen-destinations}


\section{Persistent continuations}
\label{sec:gen-letcc}

\section{Counting invariants}
\label{sec:gen-count}

% \subsection{Parity}

% \subsection{}

% \subsection{Pointer inequality}
\label{sec:pointer-inequality}
