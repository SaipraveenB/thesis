\chapter{Generative invariants}
\label{chapter-gen}

So far in this thesis, we have presented \sls~and focused on its
concurrent fragment primarily as a way of presenting transition
systems. This view focuses on synthetic transitions as a way of
relating process states. This chapter will focus on another view of
concurrent \sls~specifications as {\it grammars} for describing
well-formed process states. This view was presented previously in the
discussions of adequacy in Section~\ref{sec:framework-reggenworld} and
in Section~\ref{sec:nat-ssos-adequacy}.

The grammar-like specifications that describe well-formed process
states are called {\it generative signatures}, and generative
signatures can be used to specify sets of process states, or {\it
  worlds}. By the anaology with grammars, we could also talk about
{\it languages} of process states recognized by the grammar. In our
previous discussions of adequacy in
Section~\ref{sec:framework-reggenworld} and in
Section~\ref{sec:nat-ssos-adequacy}, the relevant world was a set of
process states that we could put in bijective correspondence with the
states of an abstract machine.  

Our primary use of generative specifications in this thesis is showing
that, under some generative signature $\Sigma_{\it Gen}$ that defines
a world $\mathcal W$, whenever $(\Psi; \Delta) \in \mathcal W$ and
$(\Psi; \Delta) \leadsto_\Sigma (\Psi'; \Delta')$ -- where $\Sigma$ is
some other signature that describes a transition system -- it is
always the case that $(\Psi'; \Delta') \in \mathcal W$. In such a
case, the world or language defined of well-formed process states is
called a {\it generative invariant} of $\Sigma$.  The purpose of this
chapter is to demonstrate that generative invariants are a reasonable
way of talking about invariants of \sls~specifications, especially
well-formedness or well-typedness invariants of substructural
operational semantics specifications like the ones presented in Part
II. This argument forms the centerpiece of the third refinement of our
central thesis:

\smallskip
\begin{quote} 
  {\bf Thesis (Part III):} {\it The \sls~specification of the operational
    semantics of a programming language is a suitable basis for formal
    reasoning about the properties of the language.}
\end{quote} 
\smallskip 

\noindent
Backing up a bit, the approximation methodology presented in
Chapter~\ref{chapter-approx} is also relevant to this refinement of
the thesis statement, as the the intent of approximation is program
abstraction, a form of formal reasoning about the properties of the
programming language. (One the other hand, approximation is a
  program transformation like operationalization, defunctionalization,
  and destination adding, which is why this chapter was presented in
  Part~II. This observation illustrates that
  Chapter~\ref{chapter-approx} sits uncertainly between Part~II and
  Part~III of this thesis.) This refinement of the thesis statement
will be further supported in Chapter~\ref{chapter-safety} when we
discuss the use of generative invariants to prove the progress
property, and therefore language safety, for SSOS specifications.

In Section~\ref{sec:gen-worlds} we recaptulate how generative
signatures define a world and show that {\it regular worlds} that
Sch\"urmann implemented in Twelf \cite{schurmann00automating} fall out
as a special case of the worlds described by generative signatures.
We will then discuss invariants of operationalized ordered abstract
machines more generally (Section~\ref{sec:gen-order}), and extend that
discussion from well-{\it formed} process states to well-{\it typed}
process states in Section~\ref{sec:gen-ordertp}.  This is not a large
technical change, but conceptually it is an important step from
thinking about adequacy-like properties to thinking about preservation
theorems. In Section~\ref{sec:gen-state} we describe how generative
invariants can be established for the sorts of stateful signatures
considered in Section~\ref{sec:richer-ordered-abstract}. In
Section~\ref{sec:gen-destinations} we consider invariants for
specifications in the image of the destination-passing transformation,
and in Section~\ref{sec:gen-letcc} we consider the peculiar case of
first-class continuations, which require us to use persistent
continuation frames. Finally, in Section~\ref{sec:gen-count} we
introduce a more complicated class of generative invariants that
capture the numerical properties of specifications that appear in the
\sls~encoding of voting and auction protocols.

\section{Worlds}
\label{sec:gen-worlds}

{\it Worlds} are nothing more or less than sets of process states
$(\Psi; \Delta)$ -- in the discussion here, we will specifically
exclude process states $(\Psi; \Delta)_{\lf\sigma}$ with a non-empty
accompanying substituion $\lf\sigma$. (The accompanying substitutions
were presented in Section~\ref{sec:sls-processstates}).

A world is described by the combination of an initial process state
and generative signature. We semi-formally define a generative
signature as follows:

\bigskip
\begin{definition}\label{def:gensig}
  A {\em generative signature} is one where the ordered, linear, and
  persistent atomic propositions can be separated into two sets -- the
  {\em terminals} and the {\em nonterminals}. Synthetic transitions
  enabled by a generative signature only consume (or reference) 
  terminals and LF terms, but they produce both terminals 
  and nonterminals.
\end{definition}
\bigskip

\noindent
A generative signature describes a world with the help of the
restriction operator $\restrictsig{(\Psi; \Delta)}{\Sigma}$ introduced
in Section~\ref{sec:framework-restriction}. If $(\Psi; \Delta)$ is
well-defined under the generative signature $\Sigma_{\it Gen}$, and
$\Sigma$ is any signature that includes all of the generative
signature's terminals (and all of its LF bits) but none of its
nonterminals, then $\restrictsig{(\Psi; \Delta)}{\Sigma}$ is only
defined when the only remaining nonterminals in $\Delta$ are
persistent and can be filtered out of $\Delta$. (As long as
$\Sigma_{\it Gen}$ and $\Sigma$ have the same LF declarations, the LF
context $\Psi$ won't have anything filtered out.) When the
classification of terminals and nonterminals is clear, we will leave
off the restricting signature and just write $\restrictsig{(\Psi;
  \Delta)}{}$.

Definition~\ref{def:gensig} is intentionally quite broad -- it need
not even be decidable whether a process state belongs to the world or
language defined by a generative signature need not be
decidable.\footnote{Proof: consider the initial state
  $(x{:}\istrue{\susp{\sf gen}})$ and the rule $\forall
  \lf{e}.\,\forall\lf{v}.\,{\sf gen} \fuse {!}({\sf
    ev}\,\lf{e}\,\lf{v}) \lefti \{ {\sf terminating}\,\lf{e} \}$. The
  predicate ${\sf gen}$ is a nonterminal, the predicate ${\sf
    terminating}$ is a terminal, and ${\sf ev}$ is the encoding of
  big-step evaluation $\obj{e \Downarrow v}$ from
  Figure~\ref{fig:example-transform-cbv}.  The language described is
  isomorphic to the set of terminating $\lambda$-calculus expressions,
  and membership in that set is undecidable.} Future tractable
analyses will therefore presumably be based upon further restrictions
of the very general Definition~\ref{def:gensig}.
Context-free grammars are one obvious specialization of generative
signatures, and -- perhaps less obviously -- the regular worlds
of Twelf \cite{schurmann00automating} are another. 


\subsection{Regular worlds}
\label{sec:gen-regularworlds}

The
regular world specifications used in Twelf
\cite{schurmann00automating} are made up of {\it blocks}. A block
describes a little piece of an LF context, and is declared in the LF
signature as follows:
\[
 {\sf blockname} :
 {\sf some}~\{\lf{a_1}{:}\tau_1\}\ldots\{\lf{a_n}{:}\tau_n\}
~{\sf block}~\{\lf{b_1}{:}\tau'_1\}\ldots\{\lf{b_m}{:}\tau'_m\}
\]
A block declaration is well formed in the signature $\Sigma$ if 
$\left(\lf{a_1}{:}\tau_1,\ldots,\lf{a_{i-1}}{:} \tau_{i-1} \right)\vdash_\Sigma
\tau_i \,{\sf type}$ for $1 \leq i \leq n$ and if 
$\left(\lf{a_1}{:}\tau_1,\ldots,\lf{a_{n}}{:} \tau_{n},
 \lf{b_1}{:}\tau'_1,\ldots,\lf{b_{j-1}}{:}\tau'_{j-1}\right) \vdash_\Sigma
\tau_j \,{\sf type}$ for $1 \leq j \leq m$. 

The first list of LF variable bindings
$\{\lf{a_1}{:}\tau_1\}\ldots\{\lf{a_n}{:}\tau_n\}$ that 
come after the ${\sf some}$ keyword describe the types
of concrete LF terms that must exist for the block to be well formed.
The second list of LF variable bindings represents the bindings that
the block actually adds to the LF context. The regular worlds of 
Twelf are defined as sets of block identifiers 
$({\sf block1} \mid \ldots \mid {\sf blockn})$. A set of block identifiers
and a Twelf signature $\Sigma$ define a world as follows: if
\smallskip
\begin{itemize}
\item $\Psi$ is a well-formed
LF context in the current world, 
\item there is a $\lf{\sigma}$ such that
$\Psi \vdash_\Sigma \lf{\sigma} :
\lf{a_1}{:}\tau_1,\ldots,\lf{a_n}{:}\tau_n$, 
\item ${\sf blockname}$ is one of the blocks in the current world, and
\item ${\sf blockname} :
 {\sf some}~\{\lf{a_1}{:}\tau_1\}\ldots\{\lf{a_n}{:}\tau_n\}
~{\sf block}~\{\lf{b_1}{:}\tau'_1\}\ldots\{\lf{b_m}{:}\tau'_m\} \in \Sigma$,
\end{itemize}
\smallskip then $\Psi, \lf{b_1}{:}\lf\sigma\tau'_1,\ldots,
\lf{b_m}{:}\lf\sigma\tau'_m$ is also a well-formed LF context in the
current world. The {\it closed world}, which is singleton set of a
process every regular world, so this definition gives us the rules for
generating a world -- a set of contexts -- from a series of block
declarations.

One simple example of a regular world (previously discussed in
Section~\ref{sec:framework-reggenworld}) is the world that just
contains arbitrary expression variables with LF type ${\sf exp}$. This
world can be described with the block ${\sf blockexp}$:
\[
 {\sf blockexp} : 
 {\sf some}
~{\sf block}~\{{\lf x}{:}{\sf exp}\}
\]
If we had a judgment ${\sf natvar}\,\lf{x}\,\lf{n}$ that associated
every LF variable $\lf{x}{:}{\sf exp}$ with some natural number
$\lf{n}{:}{\sf nat}$, then in order to make sure that every expression
variable was associated with some natural number we would use this
world:
\[
 {\sf blocknatvar} : 
 {\sf some}~\{{\lf n}{:}{\sf nat}\}
~{\sf block}~\{{\lf x}{:}{\sf exp}\}~
               \{\lf{\it nv}{:}{\sf natvar}\,\lf{x}\,\lf{n}\}
\]
The world described by the combination of ${\sf blockexp}$ and ${\sf
  blocknatvar}$ is one where every LF variable $\lf{x}{:}{\sf exp}$
is associated with either zero or one LF variables of type ${\sf
  natvar}\,\lf{x}\,\lf{n}$. Assuming that there are no constants of
type ${\sf natvar}$, a property we can easily enforce with subordination, this
gives us a uniqueness property: if ${\sf natvar}\,\lf{x}\,\lf{n}$ and
${\sf natvar}\,\lf{x}\,\lf{m}$, then $\lf{m} = \lf{n}$. 

\subsection{Regular worlds from generative signatures}

A block declaration ${\sf blockname} :
 {\sf some}~\{\lf{a_1}{:}\tau_1\}\ldots\{\lf{a_n}{:}\tau_n\}
~{\sf block}~\{\lf{b_1}{:}\tau'_1\}\ldots\{\lf{b_m}{:}\tau'_m\}$ can
be described by one rule in a generative signature:
\begin{align*}
&{\sf blockname} : 
  \forall \lf{a_1}{:}\tau_1\ldots \forall\lf{a_n}{:}\tau_n.\,
  \{ \exists \lf{b_1}{:}\tau'_1 \ldots \lf{b_m}{:}\tau'_m.\,
     \one
  \}
\intertext{Because a regular world is just a set of blocks, 
the generative signature corresponding
to a regular world contains one rule for each block in the regular
worlds's description.
The world $({\sf blockexp} \mid {\sf blockvar})$ corresponds
to the following generative signature:}
&{\sf nat} : {\sf type}, 
\\
&\mbox{\it \ldots declare constants of type ${\sf nat}$ \ldots }
\\
&{\sf exp} : {\sf type}, 
\\
&\mbox{\it \ldots declare constants of type ${\sf exp}$ \ldots }
\\
&{\sf blockexp} : 
  \{ \exists \lf{x}{:}{\sf exp}.\,\one\},
\\
&{\sf blocknatvar} : \forall \lf{n}{:}{\sf nat}.\,
  \{ \exists \lf{x}{:}{\sf exp}.\,
     \exists \lf{\it nv}{:}{\sf natvar}\,\lf{x}\,\lf{n}.\, \one \}
\end{align*}
Call this regular world signature $\Sigma_{\it RW}$. It is an extremely
simple example of a generative signature -- there are no
terminals and no nonterminals -- so the restriction operator has
no effect. The world described by $({\sf blockexp} \mid {\sf blocknatvar})$
is identical to the set of LF contexts $\Psi$ such that
$(\cdot; \cdot) \leadsto_{\Sigma_{RW}} (\Psi; \Delta)$.

\subsection{Regular worlds in substructural specifications}

From the structure of translated LF regular worlds, it is hopefully
apparent that by replacing the proposition $\one$ in the heads of the
${\sf block{*}/gen}$ rules with more interesting positive
\sls propositions,  we can extend the language of regular
worlds to allow the introduction of ordered, linear, and persistent
\sls~propositions as well. For instance, the persistent atomic proposition
${\sf blockitem}$ and the rule
${\sf blockitem/gen} : 
\forall \lf{n}. \, {\sf blockitem} \lefti \{ {\sf item}\,\lf{n} \}$,
where ${\sf item}$ is a linear predicate,
describes the world of contexts that take the form
$\left(\cdot; ~ x_1{:}\iseph{\susp{{\sf item}\,\lf{n_1}}}, ~
         \ldots, ~
         x_k{:}\iseph{\susp{{\sf item}\,\lf{n_k}}}\right)$
for some numbers $\lf{n_1}\ldots\lf{n_k}$. 

The world described by this generative signature is an invariant of a
rule like
\begin{align*}
  {\sf merge} : 
  \forall \lf{n}.\,\forall\lf{m}.\,\forall\lf{p}.\,
   {\sf item}\,\lf{n} \fuse
   {\sf item}\,\lf{m} \fuse
   {!}({\sf plus}\,\lf{n}\,\lf{m}\,\lf{p}) 
    \lefti \{ {\sf item}\,\lf{p} \}
\end{align*}
that combines two items,
where ${\sf plus}$ is  negative predicate defined with a deductive
specification in 
Figure~\ref{fig:plus}.  

These substructural generalizations 




The
simplest {\it regular worlds} are those that forbid the presence of
any LF variables -- when we adequately encode unary natural numbers
$\obj{n}$ as LF terms of type ${\sf nat}$, letting $\interp{\sf z} =
\lf{\sf z}$ and letting $\interp{{\sf s} n} = \lf{s}\,\interp{n}$, we
assume there aren't any free LF variables of type ${\sf nat}$! This is
the {\it closed world assumption}, and regular worlds can be presented
as a generalization of closed worlds.  Twelf contains both a syntax
for declaring regular worlds and facilities for checking that a
signature respects a particular regular world structure
\cite{schurmann00automating}.

The relevant building blocks in our $\lambda$-calculus encoding are
just LF variables of type $\lf{a}{:}{\sf exp}$. In other LF examples
regular worlds involve multiple context elements that must appear in
tandem. In proving adequacy for typing derivations, for instance, we
must generally assume that a variable $\lf{a}{:}{\sf exp}$ always
appears in tandem with a variable $\lf{d}{:}({\sf
  of}\,\lf{a}\,\lf{tp})$ that associates the variable with some closed
LF term $\lf{tp}$ of type ${\sf typ}$ that encodes the type of that
variable.

Regular worlds remain sufficient for the encoding of stores in Linear
LF \cite{cervesato02linear} and stacks in Ordered LF
\cite{polakow01ordered}. 

To actually show that this generative invariant is observed, let
$\Sigma_{\it item}$ be the signature including the ${\sf blockitem}$
predicate and the ${\sf blockitem/gen}$ rule, and let $\Sigma_{\it
  merge}$ be the signature including the ${\sf merge}$ rule. 
The synthetic transition associated with ${\sf merge}$ 
has the form 
\[
(\Psi; \Delta, x_1{:}\iseph{\susp{{\sf item}\,\lf{m}}},
          x_2{:}\iseph{\susp{{\sf item}\,\lf{n}}}) 
\leadsto_{\Sigma_{\it merge}} 
 (\Psi; \Delta, x{:}\iseph{\susp{{\sf item}\,\lf{p}}})\]
with the side condition that there is a derivation
of $\Psi; \cdot \vdash_{\Sigma_{\it merge}} N : 
    {\sf plus}\,\lf{n}\,\lf{m}\,\lf{p}$. 
We are given a trace
$T :: (\cdot; b{:}\ispers{\susp{{\sf blockitem}}}) \leadsto^*_{\Sigma_{\it item}}
     (\Psi'; \Delta')$ where we know that
$\restrictsig{(\Psi'; \Delta')}{\Sigma_{\it merge}}$ is defined and
$\restrictsig{(\Psi'; \Delta')}{\Sigma_{\it merge}} = 
 (\Psi, \Delta, x_1{:}\iseph{\susp{{\sf item}\,\lf{m}}},
          x_2{:}\iseph{\susp{{\sf item}\,\lf{n}}})$. 
%By a straightforward induction over the structure of $T$, we can conclude
%that $\Delta' = \Delta, x_1{:}\iseph{\susp{{\sf item}\,\lf{m}}},
%          x_2{:}\iseph{\susp{{\sf item}\,\lf{n}}}, b{:}\ispers{\susp{}})$





To proceed, we need a lemma, which we can prove 
by induction
%
and case analysis on the end of the trace $T$, that
if $T ::
(\cdot; b{:}\ispers{\susp{{\sf blockitem}}}) \leadsto^*_{\Sigma_{\it
    item}} (\Psi'; \Delta', y{:}\iseph{\susp{{\sf item}\,\lf{k}}})$
then $T = T'; \trstep{y}{{\sf blockitem/gen}\,\lf{k}\,b'}$.
While this point was discussed carefully in
Section~\ref{sec:sls-adequate} and a bit less carefully in
Section~\ref{sec:nat-ssos-adequacy}, it is worth repeating this
lemma in detail. If we look
at the last steps of the trace $T$, it must take one of the following
two forms:
\smallskip
\begin{enumerate}
\item $T = \left(T''; ~~ \trstep{y}{{\sf blockitem/gen}\,\lf{k}\,b'}
  \right)$.
  
\item $T = \left(T''; ~~ S \right)$, where $y$ is not
  introduced by $S$'s pattern (in the terminology of
  Section~\ref{sec:linconcurrenteq}, $\emptyset = S^{\bullet}
  \cap \{ y \}$).
\end{enumerate}
\smallskip
In Case 1, the result is immediate, letting $T'$ be $T''$. In Case 2, we 
use the induction hypothesis to get some $T'''$ such that
$T'' = \left(T''';
  \trstep{y}{{\sf blockitem/gen}\,\lf{k}\,b'}\right)$.
We want to conclude by saying that 
$T' = T'''; S$, but to do that we need to know that the trace
$\left(\trstep{y}{{\sf blockitem/gen}\,\lf{k}\,b'};
   S\right)$ is concurrently equal to the trace 
$\left(S; 
\trstep{y}{{\sf blockitem/gen}\,\lf{k}\,b'}\right)$.
%
Because $y$ are associated with ephemeral propositions, we
know without any further inspection that they are not part of the
input interface of $S$ (that $\emptyset = {^\bullet}S \cap \{ y
\}$), which means the desired concurrent equality does hold. 

Using two applications of this lemma (once where $y = x_1$ and $\lf{k} = \lf{m}$ and once where $y = x_2$ and $\lf{k} = \lf{n}$, we get that
\begin{align*}
T = ~ & \qquad (\Psi; \Delta, x_1{:}\iseph{\susp{{\sf item}\,\lf{m}}},
          x_2{:}\iseph{\susp{{\sf item}\,\lf{n}}}) 
\end{align*}

 lemma, we can conclude that the trace we were given, 



This is a
particularly simple case, and it is simple because the output
interfaces of the steps we're interested in do not include LF
variables or variables associated with persistent
propositions. Nevertheless, this simple assumption will suffice until
we consider destinations in Section~\ref{sec:gen-destinations}.


\section{Invariants of ordered specifications}
\label{sec:gen-order}

We have already covered one discussion of generative invariants for 
ordered abstract machine SSOS specifications. In Figure 

\begin{figure}[tp]
\fvset{fontsize=\small,boxwidth=229pt}
\VerbatimInput{sls/gen-order-prog.sls}
\caption{Ordered abstract machine with parallel evaluation and failure}
\label{fig:ssos-fail}
\end{figure}


\section{From well-formed to well-typed states}
\label{sec:gen-ordertp}

\section{Ambient state}
\label{sec:gen-state}


% \subsection{Store typing}


% \subsection{Environment semantics}

\section{Destination-passing}
\label{sec:gen-destinations}


\section{Persistent continuations}
\label{sec:gen-letcc}

\section{Counting invariants}
\label{sec:gen-count}

% \subsection{Parity}

% \subsection{}

% \subsection{Pointer inequality}
\label{sec:pointer-inequality}
