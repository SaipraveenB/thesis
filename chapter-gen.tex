\chapter{Generative specifications as invariants}
\label{chapter-gen}

% The relevant building blocks in our $\lambda$-calculus encoding are
% just LF variables of type $\lf{a}{:}{\sf exp}$. It is sometimes
% desirable to consider closed expressions, 



% but in other examples they
% involve multiple context elements that must appear in tandem. In
% proving adequacy for typing derivations, for instance, we must
% frequently prove that a variable $\lf{a}{:}{\sf exp}$ always appears
% in tandem with a variable $\lf{d}{:}({\sf of}\,\lf{a}\,\lf{tp})$ that
% associates the variable with some closed LF term $\lf{tp}$ of type
% ${\sf typ}$ that encodes the type of that variable.

% These {\it regular worlds} are not just important for proving adequacy
% theorems. They are a critical part of reasoning about LF terms: when
% we quantify over the set of LF terms of a particular type, it is
% always necessary to specify what world we are working with. In the
% case of $\lambda$-calculus terms encoded in the type ${\sf exp}$, we
% sometimes want to consider open expressions in the world of contexts
% that take the form $\lf{a_1}{:}{\sf exp},\ldots,\lf{a_n}{:}{\sf exp}$
% (for instance, when we are describing typing rules for open terms or
% defining $\beta$-reduction under binders). We also sometimes want to
% consider closed terms in the empty context (for instance, when we are
% describing call-by-value evaluation of closed expressions).  This
% choice affects the structure of case analysis: when reasoning
% about closed expressions, we do not need to provide a base case for
% when the expression is a variable, but when reasoning about open
% expressions, we obviously do.

% The {\it closed world assumption} -- considering terms in the absence
% of any LF variables -- is the simplest one. 


% The world affects the reasoning we have to do when we perform case
% analysis: when we reason about terms of type ${\sf exp}$ defined in
% the world that allows variables of type ${\sf exp}$, we have to
% consider an extra case (the term is a variable $\lf{a_i}$ from the
% context) that is not possible in the closed world. 

\section{Generalizing worlds}

The regular world specifications used in Twelf are made up of {\it
  blocks}. A block describes a little piece of an LF context, and
is declared in the LF signature as follows:
\[
 {\sf blockname} :
 {\sf some}~\{\lf{a_1}{:}\tau_1\}\ldots\{\lf{a_n}{:}\tau_n\}
~{\sf block}~\{\lf{b_1}{:}\tau'_1\}\ldots\{\lf{b_m}{:}\tau'_m\}
\]
A block declaration is well formed in the signature $\Sigma$ if 
$\left(\lf{a_1}{:}\tau_1,\ldots,\lf{a_{i-1}}{:} \tau_{i-1} \right)\vdash_\Sigma
\tau_i \,{\sf type}$ for $1 \leq i \leq n$ and if 
$\left(\lf{a_1}{:}\tau_1,\ldots,\lf{a_{n}}{:} \tau_{n},
 \lf{b_1}{:}\tau'_1,\ldots,\lf{b_{j-1}}{:}\tau_{j-1}\right) \vdash_\Sigma
\tau_j \,{\sf type}$ for $1 \leq j \leq m$. 

The first list of LF variable bindings
$\{\lf{a_1}{:}\tau_1\}\ldots\{\lf{a_n}{:}\tau_n\}$ that 
come after the ${\sf some}$ describe the types
of concrete LF terms that must exist for the block to be well formed.
The second list of LF variable bindings represent the bindings that
the block actually adds to the LF context. The regular worlds of 
Twelf are defined as sets of block identifiers 
$({\sf block1} \mid \ldots \mid {\sf blockn})$. A set of block identifiers
and a Twelf signature $\Sigma$ define a world as follows: if
\smallskip
\begin{itemize}
\item $\Psi$ is a well-formed
LF context in the current world, 
\item there is a $\lf{\sigma}$ such that
$\Psi \vdash_\Sigma \lf{\sigma} :
\lf{a_1}{:}\tau_1,\ldots,\lf{a_n}{:}\tau_n$, 
\item ${\sf blockname}$ is one of the blocks in the current world, and
\item ${\sf blockname} :
 {\sf some}~\{\lf{a_1}{:}\tau_1\}\ldots\{\lf{a_n}{:}\tau_n\}
~{\sf block}~\{\lf{b_1}{:}\tau'_1\}\ldots\{\lf{b_m}{:}\tau'_m\} \in \Sigma$,
\end{itemize}
\smallskip
then $\Psi,
\lf{b_1}{:}\lf\sigma\tau'_1,\ldots, \lf{b_m}{:}\lf\sigma\tau'_m$ is
also a well-formed LF context in the current world. The empty LF context
belongs to every regular world, so this definition gives us the rules for 
generating a world -- a set of contexts -- from a series of block 
declarations. 

The simple world we have discussed previously (for
example, in Section~\ref{sec:framework-reggenworld}) is the
world that just contains arbitrary expression variables with LF type
${\sf exp}$. This world can be described with the block ${\sf blockexp}$:
\[
 {\sf blockexp} : 
 {\sf some}
~{\sf block}~\{{\lf x}{:}{\sf exp}\}
\]
If we had a judgment ${\sf natvar}\,\lf{x}\,\lf{n}$ that associated
every LF variable $\lf{x}{:}{\sf exp}$ with some natural nubmer
$\lf{n}{:}{\sf nat}$, then in order to make sure that every expression
variable was assocaited with some natural number we would use this
world:
\[
 {\sf blocknatvar} : 
 {\sf some}~\{{\lf n}{:}{\sf nat}\}
~{\sf block}~\{{\lf x}{:}{\sf exp}\}~
               \{\lf{\it nv}{:}{\sf natvar}\,\lf{x}\,\lf{n}\}
\]
The world described by the combination of ${\sf blockexp}$ and ${\sf
  blocknatvar}$ is one where, every LF variable $\lf{x}{:}{\sf exp}$
is associated with either zero or one LF variables of type ${\sf
  natvar}\,\lf{x}\,\lf{n}$. Assuming that there are no constants of
type ${\sf natvar}$, a property we can enforce with subrodination, this
gives us a uniqueness property: if ${\sf natvar}\,\lf{x}\,\lf{n}$ and
${\sf natvar}\,\lf{x}\,\lf{m}$, then $\lf{m} = \lf{n}$. 

We can describe 
\begin{align*}
&{\sf blockname} : {\sf prop}\,{\sf pers},
\\
&{\sf blockname/gen} : 
  \forall \lf{a_1}{:}\tau_1\ldots \forall\lf{a_n}{:}\tau_n.\,
  {\sf blockname} 
    \lefti
  \{ \exists \lf{b_1}{:}\tau'_1 \ldots \lf{b_m}{:}\tau'_m.\,
     \one
  \}
\intertext{So, our two examples would be written as follows:}
&{\sf blockexp} : {\sf prop}\,{\sf pers},
\\
&{\sf blockexp/gen} : {\sf blockexp} \lefti
  \{ \exists \lf{x}{:}{\sf exp}.\,\one\},
\\
&{\sf blocknatvar} : {\sf prop}\,{\sf pers},
\\
&{\sf blocknatvar/gen} : \forall \lf{n}{:}{\sf nat}.\,
  {\sf blocknatvar} \lefti
  \{ \exists \lf{x}{:}{\sf exp}.\,
     \exists \lf{\it nv}{:}{\sf natvar}\,\lf{x}\,\lf{n}.\, \one \}
\end{align*}
Let the original signature be $\Sigma$ and the signature extended with
one persistent proposition and one rule for every block be
$\Sigma_{\it RW}$.  The regular world described by $({\sf block1} \mid
\ldots \mid {\sf blockn})$ in Twelf is precisely the set of LF
contexts $\Psi$ such that $(\cdot; x_1{:}{\sf block1}, \ldots,
x_n{:}{\sf blockn}) \leadsto_{\Sigma_{RW}} (\Psi'; \Delta')$ and
$(\Psi; \Delta) = \restrictsig{(\Psi'; \Delta')}{\Sigma}$.\footnote{We
  also know, becuase of the structure of regular worlds created from
  generative invariants, that $\Delta' = x_1{:}{\sf block1}, \ldots,
  x_n{:}{\sf blockn}$, that $\restrictsig{(\Psi'; \Delta')}{\Sigma}$
  is defined, and that $\Delta' = \cdot$. However, we won't know this
  in general when we discuss generative invariants.} 

From the structure of translated LF regular worlds, it is hopefully
apparent that by replacing the proposition $\one$ in the heads of the
${\sf block{*}/gen}$ rules with more interesting positive
\sls propositions,  we can extend the language of regular
worlds to allow the introduction of ordered, linear, and persistent
\sls~propositions as well. For instance, the persistent atomic proposition
${\sf blockitem}$ and the rule
${\sf blockitem/gen} : 
\forall \lf{n}. \, {\sf blockitem} \lefti \{ {\sf item}\,\lf{n} \}$,
where ${\sf item}$ is a linear predicate,
describes the world of contexts that take the form
$\left(\cdot; ~ x_1{:}\iseph{\susp{{\sf item}\,\lf{n_1}}}, ~
         \ldots, ~
         x_k{:}\iseph{\susp{{\sf item}\,\lf{n_k}}}\right)$
for some numbers. This world, furthermore, is preserved
under a rule like 
\[
  {\sf merge} : 
  \forall \lf{n}.\,\forall\lf{m}.\,\forall\lf{p}.\,
   {\sf item}\,\lf{n} \fuse
   {\sf item}\,\lf{m} \fuse
   {!}({\sf plus}\,\lf{n}\,\lf{m}\,\lf{p}) 
    \lefti \{ {\sf item}\,\lf{p} \}
\]
where ${\sf plus}$ is a negative predicate defined as in 
Figure~\ref{fig:plus}.


\section{Invariants of ordered specifications}

We have already covered one discussion of generative invariants for 
ordered abstract machine SSOS specifications. In Figure 

\begin{figure}[t]
\fvset{fontsize=\small,boxwidth=229pt}
\VerbatimInput{sls/gen-order-prog.sls}
\caption{Ordered abstract machine with parallel evaluation and failure}
\label{fig:ssos-fail}
\end{figure}


\section{From well-formed to well-typed states}

\section{Ambient state}

% \subsection{Store typing}


% \subsection{Environment semantics}

\section{Destinations-passing}
\label{sec:gen-destinations}


\section{Persistent continuations}
\label{sec:gen-letcc}

\section{Counting invariants}

% \subsection{Parity}

% \subsection{}

% \subsection{Pointer inequality}
\label{sec:pointer-inequality}
