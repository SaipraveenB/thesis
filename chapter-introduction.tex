\chapter{Introduction}
\label{chapter-introduction}

% The topic of this thesis is the specification of {\it evolving systems}

% The {\it lingua franca} of research in programming languages and
% logics is the {\it inductive definition}. Type systems are defined in
% terms of inductive definitions like $\Gamma \vdash e : \tau$
% (within the typing context $\Gamma$, the term $e$ has type $\tau$).
% % \[
% % \infer
% % {\Gamma \vdash x : \tau \mathstrut}
% % {x{:}\tau \in \Gamma \mathstrut}
% % \quad
% % \infer
% % {\Gamma \vdash {\sf z} : {\sf nat} \mathstrut}
% % {}
% % \quad
% % \infer
% % {\Gamma \vdash {\sf s}\,e : {\sf nat} \mathstrut}
% % {\Gamma \vdash e_1 : {\sf nat}
% %  &
% %  \Gamma \vdash e_2 : {\sf nat}}
% % \]
% Operational semantics are also defined in terms of inductive
% definitions: a {\it small-step} semantics has the form $e \mapsto e'$
% (the expression or machine state $e$ can transition to $e'$), and a
% {\it big-step} semantics has the form $e \Downarrow v$ (the expression
% or machine state $e$ can ultimately produce the terminal machine state
% $v$). 

% Proof assistants -- computer programs that help programming language
% researchers specify systems, explore their behavior, and prove
% properties of their behavior -- obviously must therefore be able to
% talk about inductive definitions. The most common way proof assistants
% do this is by directly incorporating a notion of inductive definition
% into their framework. Coq \cite{}, Agda \cite{}, ATS \cite{},
% Isabelle/HOL \cite{}, Matita \cite{}, and Abella \cite{} all work this
% way; inductive types are introduced

%  which covers all the theorem provers used to prove the POPLMark
% challenge except for Twelf.


% used in these domains therefore universally
% include a notion of {\it inductive definition} as the primary form of

A central goal of logical frameworks is to specify the operational
semantics of evolving systems (in particular, the operational
semantics of programming languages) in a framework that is logically
motivated and that allows specifications to be as simple as possible.
This thesis considers an approach to the specification of evolving
systems that is based on a family of logics called {\it substructural
  logics}.

Many interesting stateful systems have a natural notion of {\it
  ordering} that is fundamental to their behavior. Consider a
push-down automaton (PDA) that reads a string of symbols left-to-right
while maintaining and manipulating a separate stack of symbols. We can
represent any configuration of the PDA as a sequence 
with three regions:
\[
[~\mbox{the stack}~]
~
[~\mbox{the head}~]
~
[~\mbox{the string being read}~]
\]
where the symbols closest to the head are the top of the stack and the
symbol waiting to be read from the string. If we represent the head as
a token ${\sf hd}$, we can describe the behavior of a single-state
push-down automaton for checking that a string has only matching 
angle braces by using two rewriting rules:
\begin{align}
\tag{push} {\sf hd}~{<} ~&\rightsquigarrow~ {<}~{\sf hd}
\\
\tag{pop} {<}~{\sf hd}~{>} ~&\rightsquigarrow~ {\sf hd}
\end{align}
The distinguishing feature of these rewriting rules is that they are
{\it local} -- they do not mention the entire stack or the entire
string, just the relevant fragment at the beginning of the string and
the top of the stack. Execution of the PDA on a particular string of
tokens then consists of (1) appending the token ${\sf hd}$ to the
beginning of the string, (2) repeatedly performing rewritings until no
more rewrites are possible, and (3) checking to see if only a single
token ${\sf hd}$ remains. One possible series of transitions that this
rewriting system can take is shown in Figure~\ref{fig:pda-transitions}

\begin{figure}
\begin{align*}
{\sf hd}~~{<}~~{<}~~{>}~~{<}~~{<}~~{>}~~{>}~~{>}
& ~~~\rightsquigarrow~~\\
{<}~~{\sf hd}~~{<}~~{>}~~{<}~~{<}~~{>}~~{>}~~{>}
& ~~~\rightsquigarrow~~\\
{<}~~{<}~~{\sf hd}~~{>}~~{<}~~{<}~~{>}~~{>}~~{>}
& ~~~\rightsquigarrow~~\\
{<}~~{\sf hd}~~{<}~~{<}~~{>}~~{>}~~{>}
& ~~~\rightsquigarrow~~\\
{<}~~{<}~~{\sf hd}~~{<}~~{>}~~{>}~~{>}
& ~~~\rightsquigarrow~~\\
{<}~~{<}~~{<}~~{\sf hd}~~{>}~~{>}~~{>}
& ~~~\rightsquigarrow~~\\
{<}~~{<}~~{\sf hd}~~{>}~~{>}
& ~~~\rightsquigarrow~~\\
{<}~~{\sf hd}~~{>}
& ~~~\rightsquigarrow~~\\
{\sf hd} &
\end{align*}
\caption{Series of PDA transitions.}
\label{fig:pda-transitions}
\end{figure}

Because our goal is to use a framework that is both simple and
logically motivated, we turn to {\it ordered logic} (originally
presented by Lambek~\cite{lambek58mathematics}), a logic where
hypotheses have an intrinsic notion of order. The rewriting rules
we considered above can be explained as propositions in ordered
logic, where the tokens ${\sf hd}$, $>$, and $<$ are all treated as
{\it atomic propositions}:
\begin{align*}
{\sf push} &: ~~ {\sf hd} \fuse {<} ~\lefti~ \{ {<} \fuse {\sf hd} \}
\\ 
{\sf pop} &: ~~ {<} \fuse {\sf hd} \fuse {>} ~\lefti~ \{ {\sf hd} \}
\end{align*}
The symbol $\fuse$ (pronounced ``fuse'') is the binary connective for
ordered conjunction (i.e. concatenation); it binds more tightly than
$\lefti$, a binary connective for ordered implication. The curly
braces $\{ \ldots \}$ can be ignored for now.

Our logic has first-order quantification, so we can describe a more
general push-down automata that uses ${\sf left}(X)$ and ${\sf
  right}(X)$ to describe left and right angle braces ($X = {\sf an}$),
square braces ($X = {\sf sq}$), or parentheses ($X = {\sf pa}$). The
string {\sf [ \textless~\textgreater~( [ ] ) ]} could be represented
by the following sequence of ordered atomic propositions:
\[
{\sf 
  left(sq) ~~
  left(an) ~~
  right(an) ~~
  left(pa) ~~
  left(sq) ~~
  right(sq) ~~
  right(pa) ~~
  right(sq)
}
\]
The following rules describe the more general push-down automaton:
\begin{align*}
{\sf push} &: ~~ \forall x.\, 
  {\sf hd} \fuse {\sf left}(x) ~\lefti~ \{ {\sf stack}(x) \fuse {\sf hd} \}
\\ 
{\sf pop} &: ~~ \forall x.\, 
  {\sf stack}(x) \fuse {\sf hd} \fuse {\sf right}(x) ~\lefti~ \{ {\sf hd} \}
\end{align*}
Note that while we use the fuse connective to indicate adjacent tokens
in the rules above, no fuses appear in
Figure~\ref{fig:pda-transitions}. That is because the intermediate
states are not propositions in the same way rules are
propositions. Rather, the intermediate states in
Figure~\ref{fig:pda-transitions} are {\it contexts} in ordered logic,
which we will call {\it process states}. 

Part~1 of this thesis is concerned with the design of a logical
framework for specifying transition systems. The most distinctive
characteristic of these transition systems is that the intermediate
states of computation are entirely encoded in the structure of a
contexts. In this respect, the work follows in the footsteps of
Miller's Forum \cite{miller96forum}, Cervesato and Scedrov's multiset
rewriting language $\omega$ \cite{cervesato09relating}, and Watkins et
al.'s CLF \cite{watkins02concurrent}. The major contribution of this
part is the development of {\it structural focalization}, which
unifies Andreoli's work on focused logics \cite{andreoli92logic} with
the {\it hereditary substitution} technique that Watkins developed in
the context of CLF \cite{watkins02concurrent}. Chapter~2 explains
structural focalization in the context of linear logic, Chapter~3
establishes focalization for a richer substructural logic \ollll, and
Chapter~4 takes focused \ollll~and carves out \sls, a CLF-like
framework of \underline{\bf s}ubstructural \underline{\bf l}ogical
\underline{\bf s}pecifications.

\section{Substructural operational semantics}
\label{sec:intro-ssos}

We are not primarily interested in representing systems like PDAs;
rather, our main emphasis is in the representing the operational
semantics of programming languages. We can represent operational
semantics in \sls~in many ways, but we are particularly interested in a
broad specification style called {\it substructural operational
  semantics}, or SSOS.\footnote{The term {\it substructural
    operational semantics} merges structural operational semantics
  \cite{plotkin04structural}, which we seek to generalize, and
  substructural logic, which forms the basis of our specification
  framework.} SSOS is a synthesis of structural operational semantics,
abstract machines, and logical specifications.

One of our running
examples will be a call-by-value operational semantics for the untyped
lambda calculus, defined by the BNF grammar:
\[
e ::= x \mid \lambda x.e \mid e_1\,e_2
\]
Taking some slight liberties with our representation of terms, we can
describe call-by-value evaluation for this language with the same
rewriting rules we used to describe the PDA. Instead of a head ${\sf
  hd}$, our specification uses two atomic propositions: ${\sf
  eval}(e)$ for an unevaluated expression $e$, and ${\sf retn}(v)$
for an evaluated value $v$.


The evaluation of a lambda expression
is simple, as it is already a fully evaluated value, so we replace
${\sf eval}(\lambda x.e)$ in-place with ${\sf retn}(\lambda x.e)$:
\begin{align*}
{\sf ev/lam}&: ~~ 
  {\sf eval}\,(\lambda x.e) \lefti \{ {\sf retn}\,(\lambda x.e) \}
%
  \intertext{The evaluation an application $e_1\,e_2$, on the other
    hand, requires us to push a new element onto the stack. In place
    of the PDA's stack of propositions ${\sf stack}(x)$ growing off to
    the left, we maintain a stack of ${\sf cont}(f)$ propositions
    growing off to the right, where $f$ is called a {\it frame}. We
    evaluate $e_1\,e_2$ by evaluating $e_1$ and leaving behind a frame
    $\Box\,e_2$ that suspends the argument $e_2$ while $e_1$ is being
    evaluated to a value.}
%
{\sf ev/app}&: ~~ 
  {\sf eval}\,(e_1\,e_2) \lefti \{ {\sf eval}\,(e_1) 
     \fuse {\sf cont}\,(\Box\,e_2) \}
%
     \intertext{When a function is returned to a waiting $(\Box\,e_2)$
       frame, we switch to evaluating the function argument while
       storing the returned function in a frame $((\lambda
       x.e)\,\Box)$.}
%
{\sf ev/app1}&: ~~
  {\sf retn}\,(\lambda x.e) \fuse {\sf cont}\,(\Box\,e_2)
    \lefti \{ {\sf eval}\,(e_2) \fuse {\sf cont}\,((\lambda x.e)\,\Box) \}
%
    \intertext{Finally, when an evaluated function argument is
      returned to the waiting $((\lambda x.e)\,\Box)$ frame, we
      substitute the value into the body of the lambda expression and
      evaluate the result.}
%
{\sf ev/app2}&: ~~
  {\sf retn}\,(v_2) \fuse {\sf cont}\,((\lambda x.e)\,\Box)
    \lefti \{ {\sf eval}\,([v_2/x]e) \}
%
\end{align*}

\begin{figure}
\begin{align*}
{\sf eval}\,((\lambda x.x)\,((\lambda y.y)\,(\lambda z.e))) 
& ~~~\rightsquigarrow~~ \tag{by rule ${\sf ev/app}$}\\
{\sf eval}\,(\lambda x.x) \quad
{\sf cont}\,(\Box\,((\lambda y.y)\,(\lambda z.e)))
& ~~~\rightsquigarrow~~ \tag{by rule ${\sf ev/lam}$}\\
{\sf retn}\,(\lambda x.x) \quad
{\sf cont}\,(\Box\,((\lambda y.y)\,(\lambda z.e)))
& ~~~\rightsquigarrow~~ \tag{by rule ${\sf ev/app1}$}\\
{\sf eval}\,((\lambda y.y)\,(\lambda z.e)) \quad
{\sf cont}\,((\lambda x.x)\,\Box)
& ~~~\rightsquigarrow~~ \tag{by rule ${\sf ev/app}$}\\
{\sf eval}\,(\lambda y.y) \quad
{\sf cont}\,(\Box\,(\lambda z.e)) \quad
{\sf cont}\,((\lambda x.x)\,\Box)
& ~~~\rightsquigarrow~~ \tag{by rule ${\sf ev/lam}$}\\
{\sf retn}\,(\lambda y.y) \quad
{\sf cont}\,(\Box\,(\lambda z.e)) \quad
{\sf cont}\,((\lambda x.x)\,\Box)
& ~~~\rightsquigarrow~~ \tag{by rule ${\sf ev/app1}$}\\
{\sf eval}\,(\lambda z.e) \quad
{\sf cont}\,((\lambda y.y)\,\Box) \quad
{\sf cont}\,((\lambda x.x)\,\Box)
& ~~~\rightsquigarrow~~ \tag{by rule ${\sf ev/lam}$}\\
{\sf retn}\,(\lambda z.e) \quad
{\sf cont}\,((\lambda y.y)\,\Box) \quad
{\sf cont}\,((\lambda x.x)\,\Box)
& ~~~\rightsquigarrow~~ \tag{by rule ${\sf ev/app2}$}\\
{\sf eval}\,(\lambda z.e) \quad
{\sf cont}\,((\lambda x.x)\,\Box)
& ~~~\rightsquigarrow~~ \tag{by rule ${\sf ev/lam}$}\\
{\sf retn}\,(\lambda z.e) \quad
{\sf cont}\,((\lambda x.x)\,\Box)
& ~~~\rightsquigarrow~~ \tag{by rule ${\sf ev/app2}$}\\
{\sf eval}\,(\lambda z.e) 
& ~~~\rightsquigarrow~~ \tag{by rule ${\sf ev/lam}$}\\
{\sf retn}\,(\lambda z.e) 
& ~~~\not\rightsquigarrow~~ 
\end{align*}
\caption{SSOS evaluation of an expression to a value.}
\label{fig:ssos-example}
\end{figure}

These four rules constitute an SSOS specification of call-by-value
evaluation; an example of an evaluating the expression $(\lambda
x.x)\,((\lambda y.y)\,(\lambda z.e))$ to a value under this
specification is given in Figure~\ref{fig:ssos-example}.  As before,
each machine state is represented by a process state or ordered
context.

The general idea of representing the intermediate states of
computation in a programming language specification as a context in
substructural logic dates back to Miller \cite{miller92pi} and his
Ph.D. student Chirimar \cite{chirimar95proof}, who encoded the
intermediate states of a $\pi$-calculus and of a low-level RISC
machine (respectively) as contexts in focused classical linear logic.

The \sls~framework admits many styles of specification. The
SSOS specification above resides in the {\it
  concurrent} fragment of \sls. This rewriting-like fragment is called
concurrent because we can just as easily seed the process state with
two propositions ${\sf eval}(e)$ and ${\sf eval}(e')$ that will
evaluate to values concurrently, side-by-side in the process state.
On the other end of the spectrum, the {\it deductive} fragment of
\sls~supports the specification of inductive definitions by the same
methodology of adequate encoding used to represent inductive
definitions in the LF logical framework \cite{harper93framework}. 

We can therefore use the deductive fragment of \sls~to specify a
big-step operational semantics (also called a {\it natural semantics}
\cite{milner97definition}) for call-by-value evaluation by inductively
defining the judgment $e \Downarrow v$, which expresses that the
expression $e$ evaluates to the value $v$. On paper, this natural
semantics is expressed with two inference rules:
\[
\infer
{\lambda x.e \Downarrow \lambda x.e \mathstrut}
{}
\quad
\infer
{e_1\,e_2 \Downarrow v \mathstrut}
{e_1 \Downarrow \lambda x.e
 &
 e_2 \Downarrow v_2
 &
 [v_2/x]e_2 \Downarrow v \mathstrut}
\]
Natural semantics specifications are compact and elegant, but they is
not particularly {\it modular}. As a (rather contrived) example,
consider the addition of a incrementing counter ${\sf count}$ to the
language of expressions $e$. The language keeps a numeral as a
counter, and every time ${\sf count}$ is evaluated, it returns the
value of the counter and then increments the counter.\footnote{To keep
  the language small, we can represent numerals $\underline{n}$ as
  Church numerals: $\underline{0} = (\lambda f. \lambda x. x)$,
  $\underline{1} = (\lambda f. \lambda x. f x)$, $\underline{2} =
  (\lambda f. \lambda x. f (f x))$, and so on.  Then, $\underline{n} +
  1 = \lambda f. \lambda x. f e$ if $\underline{n} = \lambda
  f. \lambda x. e$.}  To extend the natural semantics with this new
feature, we have to revise all the existing rules so that they mention
the running counter:
%
\[
\infer
{({\sf count}, \underline{n}) \Downarrow 
  (\underline{n}, \underline{n} +1)}
{}
\quad 
\infer
{(\lambda x.e, \underline{n}) \Downarrow (\lambda x.e, \underline{n})
 \mathstrut}
{}
\]
\[
\infer
{(e_1\,e_2, \underline{n}) \Downarrow (v, \underline{n'}) \mathstrut}
{(e_1, \underline{n}) \Downarrow (\lambda x.e, \underline n_1)
 &
 (e_2, \underline n_1) \Downarrow (v_2, \underline n_2)
 &
 ([v_2/x]e_2, \underline n_2 ) \Downarrow (v, \underline{n'}) \mathstrut}
\]
The simple elegance of our natural semantics has been tarnished by the
need to deal with state.  

In contrast, our SSOS specification can tolerate the
addition of a counter without revision to the existing rules; we can
just store the counter's value in an atomic proposition ${\sf
  store}(\underline{n})$ to the left of the ${\sf eval}(e)$ or ${\sf
  retn}(v)$ proposition in the ordered context. Because the rules
${\sf ev/lam}$, ${\sf ev/app}$, ${\sf ev/app1}$, and ${\sf ev/app2}$
are local, they will ignore this extra proposition, which only
needs to be accessed by the rule ${\sf ev/count}$:
\begin{align*}
{\sf ev/count} &:~~
  {\sf store}\,\underline n \fuse {\sf eval}\,{\sf count}
    \lefti \{ {\sf store}\,(\underline n + 1) 
      \fuse {\sf retn}\,\underline n \}
\end{align*}
In Figure~\ref{fig:eval-ssos-ctr}, we give an example of evaluating
$(((\lambda x.\lambda y.y)\,{\sf count})\,{\sf count})$ to a value
(with a starting counter value of $\underline 5$). This solution is
even more contrived than the problem was: where do we put the {\it
  second} counter? Nevertheless, the example does foreshadow how, in
Part~2 of this thesis, we will show more generally how SSOS
specifications in \sls~allow for the the modular specification of many
programming language features, extending work done jointly with
Pfenning \cite{pfenning09substructural}.

\begin{figure}
\begin{align*}
{\sf store}\,\underline 5 \quad
{\sf eval}\,(((\lambda x.\lambda y.y)\,{\sf count})\,{\sf count})
& ~~~\rightsquigarrow~~ \tag{by rule ${\sf ev/app}$}\\
{\sf store}\,\underline 5 \quad
{\sf eval}\,((\lambda x.\lambda y.y)\,{\sf count}) \quad
{\sf cont}\,(\Box\,{\sf count})
& ~~~\rightsquigarrow~~ \tag{by rule ${\sf ev/app}$}\\
{\sf store}\,\underline 5 \quad
{\sf eval}\,(\lambda x.\lambda y.y) \quad
{\sf cont}\,(\Box\,{\sf count}) \quad
{\sf cont}\,(\Box\,{\sf count})
& ~~~\rightsquigarrow~~ \tag{by rule ${\sf ev/lam}$}\\
{\sf store}\,\underline 5 \quad
{\sf retn}\,(\lambda x.\lambda y.y) \quad
{\sf cont}\,(\Box\,{\sf count}) \quad
{\sf cont}\,(\Box\,{\sf count})
& ~~~\rightsquigarrow~~ \tag{by rule ${\sf ev/app1}$}\\
{\sf store}\,\underline 5 \quad
{\sf eval}\,{\sf count} \quad
{\sf cont}\,((\lambda x.\lambda y.y)\,\Box) \quad
{\sf cont}\,(\Box\,{\sf count})
& ~~~\rightsquigarrow~~ \tag{by rule ${\sf ev/count}$}\\
{\sf store}\,\underline 6 \quad
{\sf retn}\,\underline 5 \quad
{\sf cont}\,((\lambda x.\lambda y.y)\,\Box) \quad
{\sf cont}\,(\Box\,{\sf count})
& ~~~\rightsquigarrow~~ \tag{by rule ${\sf ev/app2}$}\\
{\sf store}\,\underline 6 \quad
{\sf eval}\,(\lambda y.y) \quad
{\sf cont}\,(\Box\,{\sf count})
& ~~~\rightsquigarrow~~ \tag{by rule ${\sf ev/lam}$}\\
{\sf store}\,\underline 6 \quad
{\sf retn}\,(\lambda y.y) \quad
{\sf cont}\,(\Box\,{\sf count})
& ~~~\rightsquigarrow~~ \tag{by rule ${\sf ev/app2}$}\\
{\sf store}\,\underline 6 \quad
{\sf eval}\,{\sf count} \quad
{\sf cont}\,((\lambda y.y)\,\Box)
& ~~~\rightsquigarrow~~ \tag{by rule ${\sf ev/count}$}\\
{\sf store}\,\underline 7 \quad
{\sf retn}\,\underline 6 \quad
{\sf cont}\,((\lambda y.y)\,\Box)
& ~~~\rightsquigarrow~~ \tag{by rule ${\sf ev/app2}$}\\
{\sf store}\,\underline 7 \quad
{\sf eval}\,\underline 6 
& ~~~\rightsquigarrow~~ \tag{by rule ${\sf ev/lam}$}\\
{\sf store}\,\underline 7 \quad
{\sf retn}\,\underline 6 
& ~~~\not\rightsquigarrow~~ 
\end{align*}
\caption{Evaluation with an imperative counter.}
\label{fig:eval-ssos-ctr}
\end{figure}

An overarching theme of Part~2 is that we can have our cake and eat it
too by deploying the {\it logical correspondence}, which was developed
jointly with Ian Zerny in unpublished work and is explained in
Chapter~5. As explained in Chapter~6, we can use logical
correspondence to directly connect the natural semantics and SSOS
specifications above; in fact, we can automatically and mechanically
derive the latter from the former. Therefore, we can specify
call-by-value evaluation as a natural semantics, and then transform it
for the purpose of modular extension. Further transformations,
developed in joint work with Pfenning \cite{simmons11logical}, create
new opportunities modular extension as discussed in Chapter~7. These
transformations also allow for the derivation of abstract analyses
(such as control flow and alias analysis) from SSOS specifications,
which is the focus of Chapter~8.

\section{Invariants in substructural logic}

(XXX Come back and write this part)

\section{Thesis}

This document aims to support the following

\begin{quote} {\bf Thesis Statement:} {\it Logical frameworks based on
    concurrent reasoning in substructural logics are suitable for
    modular specification of programming languages and formal
    reasoning about their properties}.\footnote{The original thesis
    proposal used the phrase ``forward reasoning,'' which is a synonym
    of concurrent reasoning based on the operational intuitions
    discussed in Section~\ref{sec:framework-logicprog}.}
\end{quote}

\noindent
Part~1 concerns the design of logical frameworks based on concurrent
reasoning in substructural logics and the design of \sls. Part~2
concerns the modular specification of programming language features in
\sls~and the organization of various styles of specification through
the logical correspondence. Part~3 discusses formal reasoning about
properties of concurrent \sls~specifications, with an emphasis on
establishing well-formedness invariants.
