\chapter{Introduction}
\label{chapter-introduction}

% The topic of this thesis is the specification of {\it evolving systems}

% The {\it lingua franca} of research in programming languages and
% logics is the {\it inductive definition}. Type systems are defined in
% terms of inductive definitions like $\Gamma \vdash e : \tau$
% (within the typing context $\Gamma$, the term $e$ has type $\tau$).
% % \[
% % \infer
% % {\Gamma \vdash x : \tau \mathstrut}
% % {x{:}\tau \in \Gamma \mathstrut}
% % \quad
% % \infer
% % {\Gamma \vdash {\sf z} : {\sf nat} \mathstrut}
% % {}
% % \quad
% % \infer
% % {\Gamma \vdash {\sf s}\,e : {\sf nat} \mathstrut}
% % {\Gamma \vdash e_1 : {\sf nat}
% %  &
% %  \Gamma \vdash e_2 : {\sf nat}}
% % \]
% Operational semantics are also defined in terms of inductive
% definitions: a {\it small-step} semantics has the form $e \mapsto e'$
% (the expression or machine state $e$ can transition to $e'$), and a
% {\it big-step} semantics has the form $e \Downarrow v$ (the expression
% or machine state $e$ can ultimately produce the terminal machine state
% $v$). 

% Proof assistants -- computer programs that help programming language
% researchers specify systems, explore their behavior, and prove
% properties of their behavior -- obviously must therefore be able to
% talk about inductive definitions. The most common way proof assistants
% do this is by directly incorporating a notion of inductive definition
% into their framework. Coq \cite{}, Agda \cite{}, ATS \cite{},
% Isabelle/HOL \cite{}, Matita \cite{}, and Abella \cite{} all work this
% way; inductive types are introduced

%  which covers all the theorem provers used to prove the POPLMark
% challenge except for Twelf.


% used in these domains therefore universally
% include a notion of {\it inductive definition} as the primary form of

A central goal of logical frameworks is to specify the operational
semantics of evolving systems (in particular, the operational
semantics of programming languages) in a framework that is logically
motivated and that allows specifications to be as simple as possible.
This thesis considers an approach to the specification of evolving
systems that is based on a family of logics called {\it substructural
  logics}.

Many interesting stateful systems have a natural notion of {\it
  ordering} that is fundamental to their behavior. Consider a
push-down automaton (PDA) that reads a string of symbols left-to-right
while maintaining and manipulating a separate stack of symbols. We can
represent any configuration of the PDA as a sequence 
with three regions:
\[
[~\mbox{the stack}~]
~
[~\mbox{the head}~]
~
[~\mbox{the string being read}~]
\]
where the symbols closest to the head are the top of the stack and the
symbol waiting to be read from the string. If we represent the head as
a token ${\sf hd}$, we can describe the behavior of a single-state
push-down automataton for checking that a string has only matching 
angle braces by using two rewriting rules:
\begin{align}
\tag{push} {\sf hd}~{<} ~&\rightsquigarrow~ {<}~{\sf hd}
\\
\tag{pop} {<}~{\sf hd}~{>} ~&\rightsquigarrow~ {\sf hd}
\end{align}
The distinguishing feature of these rewriting rules is that they are
{\it local} -- they do not mention the entire stack or the entire
string, just the relevant fragment at the beginning of the string and
the top of the stack. Execution of the PDA on a particular string of
tokens then consists of (1) appending the token ${\sf hd}$ to the
beginning of the string, (2) repeatedly performing rewritings until no
more rewrites are possible, and (3) checking to see if only a single
token ${\sf hd}$ remains. One possible series of transitions that this
rewriting system can take is shown in Figure~\ref{fig:pda-transitions}

\begin{figure}
\begin{align*}
{\sf hd}~~{<}~~{<}~~{>}~~{<}~~{<}~~{>}~~{>}~~{>}
& ~~~\rightsquigarrow~~\\
{<}~~{\sf hd}~~{<}~~{>}~~{<}~~{<}~~{>}~~{>}~~{>}
& ~~~\rightsquigarrow~~\\
{<}~~{<}~~{\sf hd}~~{>}~~{<}~~{<}~~{>}~~{>}~~{>}
& ~~~\rightsquigarrow~~\\
{<}~~{\sf hd}~~{<}~~{<}~~{>}~~{>}~~{>}
& ~~~\rightsquigarrow~~\\
{<}~~{<}~~{\sf hd}~~{<}~~{>}~~{>}~~{>}
& ~~~\rightsquigarrow~~\\
{<}~~{<}~~{<}~~{\sf hd}~~{>}~~{>}~~{>}
& ~~~\rightsquigarrow~~\\
{<}~~{<}~~{\sf hd}~~{>}~~{>}
& ~~~\rightsquigarrow~~\\
{<}~~{\sf hd}~~{>}
& ~~~\rightsquigarrow~~\\
{\sf hd} &
\end{align*}
\caption{Series of PDA transitions.}
\label{fig:pda-transitions}
\end{figure}

Because our goal is to use a framework that is both simple and
logically motivated, we turn to {\it ordered logic} (originally
presented by Lambek~\cite{lambek58mathematics}), a logic where
hypotheses have an intrinsic notion of order. The rewriting rules
we considered above can be explained as propositions in ordered
logic, where the tokens ${\sf hd}$, $>$, and $<$ are all treated as
{\it atomic propositions}:
\begin{align*}
{\sf push} &: ~~ {\sf hd} \fuse {<} ~\lefti~ \{ {<} \fuse {\sf hd} \}
\\ 
{\sf pop} &: ~~ {<} \fuse {\sf hd} \fuse {>} ~\lefti~ \{ {\sf hd} \}
\end{align*}
The symbol $\fuse$ (pronounced ``fuse'') is the binary connective for
ordered conjunction (i.e. concatenation); it binds more tightly than
$\lefti$, a binary connective for ordered implication. The curly
braces $\{ \ldots \}$ can be ignored for now.

Our logic has first-order quantification, so we can describe a more
general push-down automata that uses ${\sf left}(X)$ and ${\sf
  right}(X)$ to describe left and right angle braces ($X = {\sf an}$),
square braces ($X = {\sf sq}$), or parentheses ($X = {\sf pa}$). The
string {\sf [ \textless~\textgreater~( [ ] ) ]} could be represented
by the following sequence of ordered atomic propositions:
\[
{\sf 
  left(sq) ~~
  left(an) ~~
  right(an) ~~
  left(pa) ~~
  left(sq) ~~
  right(sq) ~~
  right(pa) ~~
  right(sq)
}
\]
The following rules describe the more general push-down automaton:
\begin{align*}
{\sf push} &: ~~ \forall x.\, 
  {\sf hd} \fuse {\sf left}(x) ~\lefti~ \{ {\sf stack}(x) \fuse {\sf hd} \}
\\ 
{\sf pop} &: ~~ \forall x.\, 
  {\sf stack}(x) \fuse {\sf hd} \fuse {\sf right}(x) ~\lefti~ \{ {\sf hd} \}
\end{align*}
Note that while we use the fuse connective to indicate adjacent tokens
in the rules above, no fuses appear in
Figure~\ref{fig:pda-transitions}. That is because the intermediate
states are not propositions in the same way rules are
propositions. Rather, the intermediate states in
Figure~\ref{fig:pda-transitions} are {\it contexts} in ordered logic,
which we will call {\it process states}. 

Part~1 of this thesis is concerned with the design of a logical
framework for specifying transition systems. The most distinctive
characteristic of these transition systems is that the intermediate
states of computation are entirely encoded in the structure of a
contexts. In this respect, the work follows in the footsteps of
Miller's Forum \cite{miller96forum}, Cervesato and Scedrov's multiset
rewriting language $\omega$ \cite{cervesato09relating}, and Watkins et
al.'s CLF \cite{watkins02concurrent}. The major contribution of this
part is the development of {\it structural focalization}, which
unifies Andreoli's work on focused logics \cite{andreoli92logic} with
the {\it hereditary substitution} technique that Watkins developed in
the context of CLF \cite{watkins02concurrent}. Chapter~2 explains
structural focalization in the context of linear logic, Chatper~3
establishes focalization for a richer substructural logic \ollll, and
Chapter~4 takes focused \ollll~and carves out \sls, a CLF-like
framework of \underline{\bf s}ubstructural \underline{\bf l}ogical
\underline{\bf s}pecifications.

\section{Substructural operational semantics}
\label{sec:intro-ssos}

We are not primarily interested in representing systems like PDAs;
rather, our main empahsis is in the representing the operational
semantics of programming languages. We can represent operational
semantics in \sls~in many ways, but we are particulary interested in a
broad specification style called {\it substructural operational
  semantics}, or SSOS.\footnote{The term {\it substructural
    operational semantics} merges structural operational semantics
  \cite{plotkin04structural}, which we seek to generalize, and
  substructural logic, which forms the basis of our specificaiton
  framework.} SSOS is a synthesis of structural operational semantics,
abstract machines, and logical specifications.

One of our running
examples will be a call-by-value operational semantics for the untyped
lambda calculus, defined by the BNF grammar:
\[
e ::= x \mid \lambda x.e \mid e_1\,e_2
\]
Taking some slight liberties with our representation of terms, we can
describe call-by-value evaluation for this language with the same
rewriting rules we used to describe the PDA. Instead of a head ${\sf
  hd}$, our specification uses two atomic propositions: ${\sf
  eval}(e)$ for an unevaluated expression $e$, and ${\sf retn}(v)$
for an evaluated value $v$.


The evaluation of a lambda expression
is simple, as it is already a fully evaluated value, so we replace
${\sf eval}(\lambda x.e)$ in-place with ${\sf retn}(\lambda x.e)$:
\begin{align*}
{\sf ev/lam}&: ~~ 
  {\sf eval}\,(\lambda x.e) \lefti \{ {\sf retn}\,(\lambda x.e) \}
%
  \intertext{The evaluation an application $e_1\,e_2$, on the other
    hand, requires us to push a new element onto the stack. In place
    of the PDA's stack of propositions ${\sf stack}(x)$ growing off to
    the left, we maintain a stack of ${\sf cont}(f)$ propositions
    growing off to the right, where $f$ is called a {\it frame}. We
    evaluate $e_1\,e_2$ by evaluating $e_1$ and leaving behind a frame
    $\Box\,e_2$ that suspends the argument $e_2$ while $e_1$ is being
    evaluated to a value.}
%
{\sf ev/app}&: ~~ 
  {\sf eval}\,(e_1\,e_2) \lefti \{ {\sf eval}\,(e_1) 
     \fuse {\sf cont}\,(\Box\,e_2) \}
%
     \intertext{When a function is returned to a waiting $(\Box\,e_2)$
       frame, we switch to evaluating the function argument while
       storing the returned function in a frame $((\lambda
       x.e)\,\Box)$.}
%
{\sf ev/app1}&: ~~
  {\sf retn}\,(\lambda x.e) \fuse {\sf cont}\,(\Box\,e_2)
    \lefti \{ {\sf eval}\,(e_2) \fuse {\sf cont}\,((\lambda x.e)\,\Box) \}
%
    \intertext{Finally, when an evaluated function argument is
      returned to the waiting $((\lambda x.e)\,\Box)$ frame, we
      substitute the value into the body of the lambda expression and
      evaluate the result.}
%
{\sf ev/app2}&: ~~
  {\sf retn}\,(v_2) \fuse {\sf cont}\,((\lambda x.e)\,\Box)
    \lefti \{ {\sf eval}\,([v_2/x]e) \}
%
\end{align*}

\begin{figure}
\begin{align*}
{\sf eval}\,((\lambda x.x)\,((\lambda y.y)\,(\lambda z.e))) 
& ~~~\rightsquigarrow~~ \tag{by rule ${\sf ev/app}$}\\
{\sf eval}\,(\lambda x.x) \quad
{\sf cont}\,(\Box\,((\lambda y.y)\,(\lambda z.e)))
& ~~~\rightsquigarrow~~ \tag{by rule ${\sf ev/lam}$}\\
{\sf retn}\,(\lambda x.x) \quad
{\sf cont}\,(\Box\,((\lambda y.y)\,(\lambda z.e)))
& ~~~\rightsquigarrow~~ \tag{by rule ${\sf ev/app1}$}\\
{\sf eval}\,((\lambda y.y)\,(\lambda z.e)) \quad
{\sf cont}\,((\lambda x.x)\,\Box)
& ~~~\rightsquigarrow~~ \tag{by rule ${\sf ev/app}$}\\
{\sf eval}\,(\lambda y.y) \quad
{\sf cont}\,(\Box\,(\lambda z.e)) \quad
{\sf cont}\,((\lambda x.x)\,\Box)
& ~~~\rightsquigarrow~~ \tag{by rule ${\sf ev/lam}$}\\
{\sf retn}\,(\lambda y.y) \quad
{\sf cont}\,(\Box\,(\lambda z.e)) \quad
{\sf cont}\,((\lambda x.x)\,\Box)
& ~~~\rightsquigarrow~~ \tag{by rule ${\sf ev/app1}$}\\
{\sf eval}\,(\lambda z.e) \quad
{\sf cont}\,((\lambda y.y)\,\Box) \quad
{\sf cont}\,((\lambda x.x)\,\Box)
& ~~~\rightsquigarrow~~ \tag{by rule ${\sf ev/lam}$}\\
{\sf retn}\,(\lambda z.e) \quad
{\sf cont}\,((\lambda y.y)\,\Box) \quad
{\sf cont}\,((\lambda x.x)\,\Box)
& ~~~\rightsquigarrow~~ \tag{by rule ${\sf ev/app2}$}\\
{\sf eval}\,(\lambda z.e) \quad
{\sf cont}\,((\lambda x.x)\,\Box)
& ~~~\rightsquigarrow~~ \tag{by rule ${\sf ev/lam}$}\\
{\sf retn}\,(\lambda z.e) \quad
{\sf cont}\,((\lambda x.x)\,\Box)
& ~~~\rightsquigarrow~~ \tag{by rule ${\sf ev/app2}$}\\
{\sf eval}\,(\lambda z.e) 
& ~~~\rightsquigarrow~~ \tag{by rule ${\sf ev/lam}$}\\
{\sf retn}\,(\lambda z.e) 
& ~~~\not\rightsquigarrow~~ 
\end{align*}
\caption{SSOS evaluation of an expression to a value.}
\label{fig:ssos-example}
\end{figure}

These four rules constitute a substructural operational semantics 
specification of call-by-value evaluation; an example of an evaluating
the expression $(\lambda x.x)\,((\lambda y.y)\,(\lambda z.e))$ to a value
is given in Figure~\ref{fig:ssos-example}
Abstract machine rules

\subsection{Modular and non-modular specification}
\label{sec:modularnonmodular}

(This can mostly come out of the thesis proposal, but use 
natural semantics instead of SOS.)

Natural semantics

Not modular (state), underspecified (parallel or not).


Add state in a modular way.

\subsection{Process states}

The general idea of representing the
intermediate states of a computation as contexts in substructural
logic dates back to Miller \cite{miller92pi} and his Ph.D. student
Chirimar \cite{chirimar95proof}, who encoded the intermediate states
of a $\pi$-calculus and of a low-level RISC machine (respectively) as
contexts in focused classical linear logic.

\section{Designing substructural logical frameworks}

\section{Specification styles}

\section{Invariants in substructural logic}
