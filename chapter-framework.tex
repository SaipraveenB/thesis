\chapter{Substructural logical specifications}

Logical framework time!

\section{}

\subsection{Partial dependency}
\label{sec:why-not-fully-dependent}

Talk about Jason's thesis \cite{}. Talk about the pain of concurrent 
equality \cite{}.

\section{Logic programming interpretation}
\label{sec:framework-logicprog}

In Chapter 3 I call this distinction one between ``concurrent and deductive''
proofs, operationally it's the difference between forward chaining 
and backward chaining. Maintaining the distinction between these is why
we don't want the class $p^-_\mlax$ in the logic.

We have talked about {\it concurrent} and {\it deductive} proof
objects, and also about the intuitive notion of {\it concurrent
  computation} as the non-backtracking, forward-chaining 

\subsection{Modes and well-moded specifications}
\label{sec:framework-modes}

\section{Adequate encoding}

The lambda
cacluslus usually has application $e_1\,e_2$ (encoded in LF as ${\sf
  app}\,\interp{e_1}\,\interp{e_2}$) and abstraction $\lambda x.e$
(encoded in LF as ${\sf lam}\,\lambda x. \interp{e}$). 



