\chapter{Destination-passing}
\label{chapter-destinations}

The natural notion of ordering provided by ordered linear logic
is quite convienent for encoding transition systems that 
have a stack or tree-based control structure. The ordered
abstract machine SSOS specifications from Chapter~6 demonstrate
this; another example is the push-down automata for parenthesis
matching discussed in the introduction, which we can now present,
in Figure~\ref{fig:pda-ord}, as an \sls~specification.

\begin{figure}[ht]
\fvset{fontsize=\small,boxwidth=229pt}
\VerbatimInput{sls/pda-ord.sls}
\caption{Ordered \sls~specification of a PDA for parenthesis matching.}
\label{fig:pda-ord}
\end{figure}

The natural expression of order provided by \sls~makes ordered
abstract machine specifications and the PDA specification in
Figure~\ref{fig:pda-ord} much more concise. However, in a way that we
will make precise in this chapter, ordered logic does not actually add
any more {\it expressiveness} to concurrent specifications relative to
linear logic. In Chapter~5, we argued that ordered abstract machines
were at least as expressive as (moded) natural semantics by giving a
transformation, operationalization, from the latter to the
former. Analogusly, in this chapter we will argue that concurrent
specifications in linear logic are just as expressive as concurrent
specifications in ordered logic by giving a transformation, {\it
  destination-adding}, from the latter to the former.  As 
originally presented by Pfenning and I in \cite{simmons11logical}, 
the destination-adding transformation turns all ordered
atomic propositions into linear atomic propositions, but tagged them
with two new arguments (the destinations of the destination-adding
transformation) that serve as a link between the formerly-ordered
atomic proposition and the formerly-ordered atomic propositions that
were previously to their left and to their right. 

Destinations (terms of type ${\sf dest}$) have no constructors, they
are only introduced as variables by existential quantification.  When
we perform the destination-adding transformation on the PDA in
Figure~\ref{fig:pda-ord}, we get the PDA in Figure~\ref{fig:pda-lin}.


\begin{figure}
\fvset{fontsize=\small,boxwidth=229pt}
\VerbatimInput{sls/pda-lin.sls}
\caption{Linear \sls~specification of a PDA for parenthesis matching.}
\label{fig:pda-lin}
\end{figure}

As an aside, the specification in Figure~\ref{fig:pda-lin}, like every
other specification that results from destination-adding, has no
occurances of ${\downarrow}A^-$ and no ordered atomic propositions. By
the discussion in Section~\ref{sec:perm-fragments}, we would therefore
be justified in viewing this specification as a linear logical
specification (or a CLF specification) instead of a ordered logical
specification in \sls.  This would not impact the structure of the
derivations significantly; essentially, it just means that we would
write $A^+_1 \lolli \{ A^+_2 \}$ instead of $A^+_1 \lefti \{ A^+_2
\}$.  This reinterpretation was used in \cite{simmons11logical}, but
we will stick with the notation of ordered logic for consistency,
while recognizing that there is nothing ordered
about specifications like the one in Figure~\ref{fig:pda-lin}. 

When the destination-adding translation is applied to ordered abstract
machine SSOS specifications, the result is a style of SSOS
specification called {\it destination-passing}. Destination-passing
specifications were the original style of SSOS specification proposed
in the CLF tech reports~\cite{cervesato02concurrent}. Whereas the
operationalization transformation exposed the structure of natural
semantics proofs so that they could be modularly extended with
stateful features, the destination-adding translation exposes the
control structure of specifications, allowing the language to be
modularly extended with control effects and effects like
synchronoization in concurrent specifications.

\section{Logical transformation: destination-adding}
\label{sec:destination-adding}

The destination-adding translation presented here is essentially the
same as the one presented and proved correct in
\cite{simmons11logical}. The translation in that paper operated over
rules of the form $\forall \overline{x}. S_1 \righti \{ S_2 \}$,
whereas ours will operate over rules of the form $\forall
\overline{x}. S_1 \lefti \{ S_2 \}$, but the difference between
$\righti$ and $\lefti$ is irrelevant for first-order
\sls~specifications.\footnote{The monad $\{ S_2 \}$ did not actually
  appear in \cite{simmons11logical}, and the presentation took
  polarity into account but was not explicitly polarized. We are
  justified in reading the lax modality back in by the sort of erasure
  argument discussed in Section~\ref{sec:perm-fragments}.} The syntactic
category $S$ is a refinement of the positive types $A^+$ defined by
the following grammar:
\[
S ::= p^+_\mpers \mid p^+_\meph \mid p^+ \mid \one
\mid t \doteq s \mid S_1 \fuse S_2 \mid \exists x{:}\tau. S
\]
The translation of a rule $\forall \overline{x}. S_1 \lefti \{ S_2 \}$
is then $\forall \overline{x}.\, \forall d_L{:}{\sf dest}.\, \forall
d_R{:}{\sf dest}.\, \llbracket S_1 \rrbracket^{d_L}_{d_R} \lefti \{
\llbracket S_2 \rrbracket^{d_L}_{d_R} \}$, where $\llbracket S
\rrbracket^{d_L}_{d_R}$ is defined in Figure~\ref{fig:destadd-pos}. It
is also necessary to transform all ordered predicates with kind
$\Pi. x_1{:}\tau_1\ldots \Pi.x_n{:}\tau_n.\,{\sf prop\,ord}$ that are
declared in the signature into predicates with kind
$\Pi. x_1{:}\tau_1\ldots \Pi.x_n{:}\tau_n.\, \Pi.d_L{:}{\sf dest}.\,
\Pi.d_R{:}{\sf dest}.\, {\sf prop\,ord}$ in order for the translation
of an ordered atomic proposition $p^+$ to reamin a valid type in
the transformed signature.

\begin{figure}
\begin{align*}
\llbracket p^+ \rrbracket^{d_L}_{d_R} & := 
 {\sf a}\,t_1\ldots t_n\,d_L\,d_R ~~~ \mbox{(where $p^+ = {\sf a}\,t_1\ldots t_n$)}
\\
\llbracket p^+_\meph \rrbracket^{d_L}_{d_R} & := p^+_\meph \fuse d_L \doteq d_R
\\
\llbracket p^+_\mpers \rrbracket^{d_L}_{d_R} & := p^+_\mpers \fuse d_L \doteq d_R
\\
\llbracket \one \rrbracket^{d_L}_{d_R} & := d_L \doteq d_R
\\
\llbracket t \doteq s \rrbracket^{d_L}_{d_R} & := t \doteq s \fuse d_L \doteq d_R
\\
\llbracket S_1 \fuse S_2 \rrbracket^{d_L}_{d_R} & := 
 \exists d_M{:}{\sf dest}.\, 
   \llbracket S_1 \rrbracket^{d_L}_{d_M}
   \fuse
   \llbracket S_2 \rrbracket^{d_M}_{d_R}
\\
\llbracket \exists x{:}\tau.\,S \rrbracket^{d_L}_{d_R} & := 
 \exists x{:}\tau.\, \llbracket S \rrbracket^{d_L}_{d_R}
\end{align*}
\caption{Destination-adding transformation on positive propositions.}
\label{fig:destadd-pos}
\end{figure}

According to Figure~\ref{fig:destadd-pos}, the rule 
${\sf pop}$ in Figure~\ref{fig:pda-lin} should actually be written as
follows:
\begin{align*} 
  {\sf pop} & : 
  \forall x{:}{\sf tok}.\,
  \forall l{:}{\sf dest}.\,
  \forall r{:}{\sf dest}.\,
  \\
  & \qquad (\exists m_1{:}{\sf dest}.\, {\sf stack}\,x\,l\,m \fuse
   (\exists m_2{:}{\sf dest}.\, {\sf hd}\,m_1\,m_2 \fuse
     {\sf right}\,x\,m_2\,r))
  \\ 
  & \qquad\quad \lefti
  \{ 
    {\sf hd}\,l\,r
  \}
\end{align*}
The destination-passing transformation as
implemented\robnote{Implement, or don't say this; also discuss the
  implementation of the probably-correct transformation on
  higher-order specs if you get to that.} produces rules that are
equivalent to the specification in Figure~\ref{fig:destadd-pos}
but that avoid unnecessary equalities and push existential quantifiers
as far out as possible to get specifications that look more like
Figure~\ref{fig:pda-lin}. 

We could consider another simplification: is it necessary to generate
a new destination $m$ by existential quantification in the head
$\exists m.\,{\sf stack}\,x\,l\,m \fuse {\sf hd}\,m\,r$ of ${\sf
  push}$ in Figure~\ref{fig:pda-lin}? There is already a destination
$m$ mentioned in the head that will be unused in the conclusion.  And
for the translation that takes all formerly-ordered atomic
propositions to linear atomic propositions, it would, in fact, be
possible to avoid generating new destinations in the transformation of
rules $\forall \overline{x}.\,S_1 \lefti \{ S_2 \}$ where the head
$S_2$ contains no more ordered atomic propositions than the premise
$S_1$. 

We preserve this quantifier in part because, as presented above, our
translation closely follows the contours of work by Morrill, Moot, and
Piazza on translating ordered logic into linear logic
\cite{morrill95higher,moot01linguistic}. That work is, in turn, based
on van Benthem's relational models of ordered logic, which closely
associate multiplicative conjunction $A \fuse B$ with exisential
quantification \cite{vanbenthem91relational}. In some ways, the
aforemntioned translations are more general than our
destination-adding transformation, as they handle a uniform logic
instead of the concurrent fragment presented here and in here
\cite{simmons11logical}. On the other hand, those translations only
operate on a propositional fragment without the unit of multiplicative
conjunction $\one$; as discussed in \cite[p.~57]{simmons11logical},
the addition non-ordered atomic propositions, $\one$, and $t \doteq s$
complicates matters significantly. The transformation as we have given
it also simplifies the proof, and the additional existential quantifiers
give us more structure to work with in the proof of 

% Another reason for preserving the existential quantifier in the head
% of the ${\sf push}$ rule is that it allows us to make an extension to
% the destination-adding transformation beyond what was considered in
% \cite{simmons11logical}. As long as the head of every translated rule
% contains at least one formerly-ordered atomic proposition that has
% been turned into a linear atomic propsition, it is possible to 
% without breaking Theorem~\ref{thm:destcorrect}. 

%  The correctness of the transformation 
% depends critically on the fact that every portion of the context
% that might be used to successfully right focus on a translated positive 
% proposition $\llbracket S \rrbracket^{d_L}_{d_R}$ is a 

\bigskip
\begin{theorem}[Correctness of destination-adding]~\\\label{thm:destcorrect}
$(\Psi; \Delta) \leadsto_\Sigma (\Psi; \Delta')$ if and only if
$(\Psi; \llbracket \Delta \rrbracket^{d_L}_{d_R}) \leadsto_{{\it Dest}(\Sigma)}
 (\Psi; \llbracket \Delta' \rrbracket^{d_L}_{d_R})$.
\end{theorem}

\begin{proof}
As in \cite[Appendix A]{simmons11logical}.
\end{proof}

Their work was more general
in that it dealt 

 this work (which only
considered the propositional fragment of ordered logic and did not
consider $\one$, 


\begin{figure}
\fvset{fontsize=\small,boxwidth=229pt}
\VerbatimInput{sls/dest-vestige.sls}
\caption{Translation of Figure~\ref{cbv-ev-ssos-fun} with vestigial destinations.}
\label{fig:dest-vestige}
\end{figure}

\subsection{Vestigial destinations}

When we apply the translation of expressions to the call-by-value 
lambda calculus specification from Figure~\ref{cbv-ev-ssos-fun}, we get
the specification in Figure~\ref{fig:dest-vestige}, which is nice but
has 

\begin{figure}
\fvset{fontsize=\small,boxwidth=229pt}
\VerbatimInput{sls/dest-cbv.sls}
\caption{Translation of Figure~\ref{cbv-ev-ssos-fun} without vestigial destinations.}
\label{fig:dest-cbv}
\end{figure}


\subsection{Persistent destination passing}

\begin{figure}
\fvset{fontsize=\small,boxwidth=229pt}
\VerbatimInput{sls/pda-pers.sls}
\caption{Linear/persistent \sls~specification of a PDA for parenthesis
  matching.}
\label{fig:pda-pers}
\end{figure}

It is not the case (as I originally conjectured) that this is possible
for specifications to be blindly turned into persistent forward-chaining
specifications 

\section{Alternate semantics for parallelism and exceptions}
\label{sec:modular-parallelism}

\section{First-class continuations}

\section{Exploring the richer fragment}

\subsection{Futures}

\subsection{Process calculus}

\subsection{First-class continuations}

\section{Why not just destinations?}

Seeing as the destination-passing semantics is the most general form
of substructural operational semantics presentation, and that it
subsumes both the ordered abstract machine semantics, it is worth
addressing the question: why not do {\it all} our work as a
destination-passing semantics? We could! But just as our goal in the
modular specification of programming languages is to make sure that
the semantics of call-by-need evaluation doesn't infect the
description of the semantics of

(Illustrate a hypothetical language development: natural numbers,
booleans, functions are specified with natural semantics, parallel
pairs, mutable state, and exceptions are specified with ordered
abstract machine semantics, and the pair/exception interface,
continations, and recursive suspensions are specified with
destination-passing semantics.)

