\chapter{Destination-passing}
\label{chapter-destinations}

The natural notion of ordering provided by ordered linear logic
is quite convienent for encoding transition systems that 
have a stack or tree-based control structure. The ordered
abstract machine SSOS specifications from Chapter~6 demonstrate
this; another example is the push-down automata for parenthesis
matching discussed in the introduction, which we can now present,
in Figure~\ref{fig:pda-ord}, as an \sls~specification.

\begin{figure}[ht]
\fvset{fontsize=\small,boxwidth=229pt}
\VerbatimInput{sls/pda-ord.sls}
\caption{Ordered \sls~specification of a PDA for parenthesis matching.}
\label{fig:pda-ord}
\end{figure}

The natural expression of order provided by \sls~makes ordered
abstract machine specifications and the PDA specification in
Figure~\ref{fig:pda-ord} much more concise. However, in a way that we
will make precise in this chapter, ordered logic does not actually add
any more {\it expressiveness} to concurrent specifications relative to
linear logic. In Chapter~5, we argued that ordered abstract machines
were at least as expressive as (moded) natural semantics by giving a
transformation, operationalization, from the latter to the
former. Analogusly, in this chapter we will argue that concurrent
specifications in linear logic are just as expressive as concurrent
specifications in ordered logic by giving a transformation, {\it
  destination-adding}, from the latter to the former.  As 
originally presented by Pfenning and I in \cite{simmons11logical}, 
the destination-adding transformation turns all ordered
atomic propositions into linear atomic propositions, but tagged them
with two new arguments (the destinations of the destination-adding
transformation) that serve as a link between the formerly-ordered
atomic proposition and the formerly-ordered atomic propositions that
were previously to their left and to their right. 

Destinations (terms of type ${\sf dest}$) have no constructors, they
are only introduced as variables by existential quantification.  When
we perform the destination-adding transformation on the PDA in
Figure~\ref{fig:pda-ord}, we get the PDA in Figure~\ref{fig:pda-lin}.


\begin{figure}
\fvset{fontsize=\small,boxwidth=229pt}
\VerbatimInput{sls/pda-lin.sls}
\caption{Linear \sls~specification of a PDA for parenthesis matching.}
\label{fig:pda-lin}
\end{figure}

As an aside, the specification in Figure~\ref{fig:pda-lin}, like every
other specification that results from destination-adding, has no
occurances of ${\downarrow}A^-$ and no ordered atomic propositions. By
the discussion in Section~\ref{sec:perm-fragments}, we would therefore
be justified in viewing this specification as a linear logical
specification (or a CLF specification) instead of a ordered logical
specification in \sls.  This would not impact the structure of the
derivations significantly; essentially, it just means that we would
write $A^+_1 \lolli \{ A^+_2 \}$ instead of $A^+_1 \lefti \{ A^+_2
\}$.  This reinterpretation was used in \cite{simmons11logical}, but
we will stick with the notation of ordered logic for consistency,
while recognizing that there is nothing ordered
about specifications like the one in Figure~\ref{fig:pda-lin}. 

When the destination-adding translation is applied to ordered abstract
machine SSOS specifications, the result is a style of SSOS
specification called {\it destination-passing}. Destination-passing
specifications were the original style of SSOS specification proposed
in the CLF tech reports~\cite{cervesato02concurrent}. Whereas the
operationalization transformation exposed the structure of natural
semantics proofs so that they could be modularly extended with
stateful features, the destination-adding translation exposes the
control structure of specifications, allowing the language to be
modularly extended with control effects and effects like
synchronoization in concurrent specifications.

\section{Logical transformation: destination-adding}
\label{sec:destination-adding}

The destination-adding translation presented here is essentially the
same as the one presented and proved correct in
\cite{simmons11logical}. The translation in that paper operated over
rules of the form $\forall \overline{x}. S_1 \righti \{ S_2 \}$,
whereas ours will operate over rules of the form $\forall
\overline{x}. S_1 \lefti \{ S_2 \}$, but the difference between
$\righti$ and $\lefti$ is irrelevant for first-order
\sls~specifications.\footnote{The monad $\{ S_2 \}$ did not actually
  appear in \cite{simmons11logical}, and the presentation took
  polarity into account but was not explicitly polarized. We are
  justified in reading the lax modality back in by the sort of erasure
  argument discussed in Section~\ref{sec:perm-fragments}.} The syntactic
category $S$ is a refinement of the positive types $A^+$ defined by
the following grammar:
\[
S ::= p^+_\mpers \mid p^+_\meph \mid p^+ \mid \one
\mid t \doteq s \mid S_1 \fuse S_2 \mid \exists x{:}\tau. S
\]
The translation of a rule $\forall \overline{x}. S_1 \lefti \{ S_2 \}$
is then $\forall \overline{x}.\, \forall d_L{:}{\sf dest}.\, \forall
d_R{:}{\sf dest}.\, \llbracket S_1 \rrbracket^{d_L}_{d_R} \lefti \{
\llbracket S_2 \rrbracket^{d_L}_{d_R} \}$, where $\llbracket S
\rrbracket^{d_L}_{d_R}$ is defined in Figure~\ref{fig:destadd-pos}. It
is also necessary to transform all ordered predicates with kind
$\Pi. x_1{:}\tau_1\ldots \Pi.x_n{:}\tau_n.\,{\sf prop\,ord}$ that are
declared in the signature into predicates with kind
$\Pi. x_1{:}\tau_1\ldots \Pi.x_n{:}\tau_n.\, \Pi.d_L{:}{\sf dest}.\,
\Pi.d_R{:}{\sf dest}.\, {\sf prop\,ord}$ in order for the translation
of an ordered atomic proposition $p^+$ to reamin a valid type in
the transformed signature.

\begin{figure}
\begin{align*}
\llbracket p^+ \rrbracket^{d_L}_{d_R} & := 
 {\sf a}\,t_1\ldots t_n\,d_L\,d_R ~~~ \mbox{(where $p^+ = {\sf a}\,t_1\ldots t_n$)}
\\
\llbracket p^+_\meph \rrbracket^{d_L}_{d_R} & := p^+_\meph \fuse d_L \doteq d_R
\\
\llbracket p^+_\mpers \rrbracket^{d_L}_{d_R} & := p^+_\mpers \fuse d_L \doteq d_R
\\
\llbracket \one \rrbracket^{d_L}_{d_R} & := d_L \doteq d_R
\\
\llbracket t \doteq s \rrbracket^{d_L}_{d_R} & := t \doteq s \fuse d_L \doteq d_R
\\
\llbracket S_1 \fuse S_2 \rrbracket^{d_L}_{d_R} & := 
 \exists d_M{:}{\sf dest}.\, 
   \llbracket S_1 \rrbracket^{d_L}_{d_M}
   \fuse
   \llbracket S_2 \rrbracket^{d_M}_{d_R}
\\
\llbracket \exists x{:}\tau.\,S \rrbracket^{d_L}_{d_R} & := 
 \exists x{:}\tau.\, \llbracket S \rrbracket^{d_L}_{d_R}
\end{align*}
\caption{Destination-adding transformation on positive propositions.}
\label{fig:destadd-pos}
\end{figure}

According to Figure~\ref{fig:destadd-pos}, the rule 
${\sf pop}$ in Figure~\ref{fig:pda-lin} should actually be written as
follows:
\begin{align*} 
  {\sf pop} & : 
  \forall x{:}{\sf tok}.\,
  \forall l{:}{\sf dest}.\,
  \forall r{:}{\sf dest}.\,
  \\
  & \qquad (\exists m_1{:}{\sf dest}.\, {\sf stack}\,x\,l\,m \fuse
   (\exists m_2{:}{\sf dest}.\, {\sf hd}\,m_1\,m_2 \fuse
     {\sf right}\,x\,m_2\,r))
  \\ 
  & \qquad\quad \lefti
  \{ 
    {\sf hd}\,l\,r
  \}
\end{align*}
The destination-adding transformation as
implemented\robnote{Implement, or don't say this; also discuss the
  implementation of the probably-correct transformation on
  higher-order specs if you get to that.} produces rules that are
equivalent to the specification in Figure~\ref{fig:destadd-pos}
but that avoid unnecessary equalities and push existential quantifiers
as far out as possible to get specifications that look more like
Figure~\ref{fig:pda-lin}. We write the result of the destination-adding
transformation on the signature $\Sigma$ as ${\it Dest}(\Sigma)$. 

We could consider another simplification: is it necessary to generate
a new destination $m$ by existential quantification in the head
$\exists m.\,{\sf stack}\,x\,l\,m \fuse {\sf hd}\,m\,r$ of ${\sf
  push}$ in Figure~\ref{fig:pda-lin}? There is already a destination
$m$ mentioned in the head that will be unused in the conclusion.  And
for the translation that takes all formerly-ordered atomic
propositions to linear atomic propositions, it would, in fact, be
possible to avoid generating new destinations in the transformation of
rules $\forall \overline{x}.\,S_1 \lefti \{ S_2 \}$ where the head
$S_2$ contains no more ordered atomic propositions than the premise
$S_1$. 

We preserve this quantifier in part because, as presented above, our
translation closely follows the contours of work by Morrill, Moot, and
Piazza on translating ordered logic into linear logic
\cite{morrill95higher,moot01linguistic}. That work is, in turn, based
on van Benthem's relational models of ordered logic, which closely
associate multiplicative conjunction $A \fuse B$ with exisential
quantification \cite{vanbenthem91relational}. In some ways, the
aforemntioned translations are more general than our
destination-adding transformation, as they handle a uniform logic
instead of the concurrent fragment presented here and in here
\cite{simmons11logical}. On the other hand, those translations only
operate on a propositional fragment without the unit of multiplicative
conjunction $\one$; as discussed in \cite[p.~57]{simmons11logical},
the addition non-ordered atomic propositions, $\one$, and $t \doteq s$
complicates matters significantly. 

In addition to following van Bentham's relational models, the
transformation as we have given it simplifies the correctness
proof (Theorem~\ref{thm:destcorrect}). The additional existential
quantifiers give us more structure to work with when considering
program abstraction in Chapter 8, and the result of applying the
transformation to ordered abstract machines is more in line with 
existing destination-passing SSOS specifications.

% Another reason for preserving the existential quantifier in the head
% of the ${\sf push}$ rule is that it allows us to make an extension to
% the destination-adding transformation beyond what was considered in
% \cite{simmons11logical}. As long as the head of every translated rule
% contains at least one formerly-ordered atomic proposition that has
% been turned into a linear atomic propsition, it is possible to 
% without breaking Theorem~\ref{thm:destcorrect}. 

%  The correctness of the transformation 
% depends critically on the fact that every portion of the context
% that might be used to successfully right focus on a translated positive 
% proposition $\llbracket S \rrbracket^{d_L}_{d_R}$ is a 

To prove the correctness of destination-adding, we must describe a 
translation $\llbracket \Psi; \Delta \rrbracket$ from process states
with ordered, linear, and persistent atomic propositions to ones
with only linear and persistent atomic propositions:
\begin{align*}
\llbracket \Psi; \cdot \rrbracket & = (\Psi, d_L{:}{\sf dest}; \cdot) 
\\
\llbracket \Psi; \Delta, x{:}\susp{{\sf a}\,t_1\ldots t_n} \rrbracket 
& = (\Psi', d_L{:}{\sf dest}, d_R{:}{\sf dest}; 
     \Delta', x{:}\susp{{\sf a}\,t_1\ldots t_n\,d_L\,d_R})\\
& \qquad
  \mbox{(where $\sf a$ is ordered and
  $\llbracket \Psi; \Delta \rrbracket = (\Psi', d_L{:}{\sf dest}; \Delta') $)}
\\
\llbracket \Psi; \Delta, x{:}\susp{p^+_\meph} \rrbracket 
& = (\Psi'; \Delta', x{:}\susp{p^+\meph})
 \qquad \mbox{(where
       $\llbracket \Psi; \Delta \rrbracket = (\Psi'; \Delta') $)}
\\
\llbracket \Psi; \Delta, x{:}\susp{p^+_\mpers} \rrbracket 
& = (\Psi'; \Delta', x{:}\susp{p^+\mpers})
  \qquad \mbox{(where 
       $\llbracket \Psi; \Delta \rrbracket = (\Psi'; \Delta') $)}
\end{align*}

\begin{theorem}[Correctness of destination-adding]~\\\label{thm:destcorrect}
$\llbracket \Psi; \Delta \rrbracket \leadsto_{{\it Dest}(\Sigma)}
 (\Psi_l; \Delta_l)$ if and only if 
$(\Psi; \Delta) \leadsto_\Sigma (\Psi_o; \Delta_o)$ and
$(\Psi_l; \Delta_l) = \llbracket \Psi_o, \Psi''; \Delta_o \rrbracket$ 
for some variable 
context $\Psi''$ containing destinations free in the first translated
context but not the second.
\end{theorem}

\begin{proof}
As in \cite[Theorem 2]{simmons11logical}.\robnote{Double check how the 
variable slack works.}
\end{proof}

\begin{figure}[t]
\fvset{fontsize=\small,boxwidth=229pt}
\VerbatimInput{sls/dest-vestige.sls}
\caption{Translation of Figure~\ref{fig:cbv-ev-ssos-fun} with vestigial destinations.}
\label{fig:dest-vestige}
\end{figure}

If we leave off explicitly mentioning the variable context $\Psi$, 
then the trace that represents successfully processing 
the string {\sf [ ( ) ] }
with the transformed push-down automata 
specification in Figure~\ref{fig:pda-lin} 
is as follows (we again underline ${\sf hd}$
for emphasis):
\begin{align*}
           & y_0{:}\susp{\underline{\sf hd}\,d_0\,d_1},
             x_1{:}\susp{{\sf left}\,{\sf sq}\,d_1\,d_2},
             x_2{:}\susp{{\sf left}\,{\sf pa}\,d_2\,d_3},
             x_3{:}\susp{{\sf right}\,{\sf pa}\,d_3\,d_4},
             x_4{:}\susp{{\sf right}\,{\sf sq}\,d_4\,d_5}
\\
\leadsto ~ & z_1{:}\susp{{\sf stack}\,{\sf sq}\,d_0\,d_6},
             y_1{:}\susp{\underline{\sf hd}\,d_6\,d_2}
             x_2{:}\susp{{\sf left}\,{\sf pa}\,d_2\,d_3},
             x_3{:}\susp{{\sf right}\,{\sf pa}\,d_3\,d_4},
             x_4{:}\susp{{\sf right}\,{\sf sq}\,d_4\,d_5}
\\
\leadsto ~ & z_1{:}\susp{{\sf stack}\,{\sf sq}\,d_0\,d_6},
             z_2{:}\susp{{\sf stack}\,{\sf pa}\,d_6\,d_7},
             y_2{:}\susp{\underline{\sf hd}\,d_7\,d_3}
             x_3{:}\susp{{\sf right}\,{\sf pa}\,d_3\,d_4},
             x_4{:}\susp{{\sf right}\,{\sf sq}\,d_4\,d_5}
\\
\leadsto ~ & z_1{:}\susp{{\sf stack}\,{\sf sq}\,d_0\,d_6},
             y_3{:}\susp{\underline{\sf hd}\,d_6\,d_4}
             x_4{:}\susp{{\sf right}\,{\sf sq}\,d_4\,d_5}
\\
\leadsto ~ & y_4{:}\susp{\underline{\sf hd}\,d_0\,d_5}
\end{align*}


\begin{figure}
\fvset{fontsize=\small,boxwidth=229pt}
\VerbatimInput{sls/dest-cbv.sls}
\caption{Translation of Figure~\ref{fig:cbv-ev-ssos-fun} without vestigial destinations.}
\label{fig:dest-cbv}
\end{figure}



\subsection{Vestigial destinations}

When we apply the translation of expressions to the call-by-value
lambda calculus specification from Figure~\ref{fig:cbv-ev-ssos-fun},
we get the specification in Figure~\ref{fig:dest-vestige}, which is
has one problem: the second argument to ${\sf eval}$ and ${\sf retn}$
is always $d'$, and the destination never changes; it is essentially a
vestage of the destination-adding transformation. As long as we are
transforming a sequential ordered abstract machine, we can eliminate
this vestigaial destination, giving us the specification in
Figure~\ref{fig:dest-cbv}. This extra destination is {\it not}
vestigial when we translate a parallel specification, but as we
discuss in Section~\ref{sec:modular-parallelism}, we don't necessarily
want to run destination-adding on parallel ordered abstract machines
anyway.

\subsection{Persistent destination passing}

When we translate our PDA specification, it is actually not necessary
to translate ${\sf hd}$, ${\sf left}$, ${\sf right}$ and ${\sf stack}$ into
linear atomic propositions; if we translate ${\sf hd}$ as
a linear predicate but translate the other predicates as persistent
predicates, it will still be the case that there is always exactly one
linear atomic proposition ${\sf hd}\,d_L\,d_R$ in the context, at most one
${\sf stack}\,x\,d\,d_L$ proposition with the same destination $d_L$, 
and at most one ${\sf right}\,x\,d_R\,d$ or ${\sf left}\,x\,d_R\,d$ 
with the same destination $d_R$. This means it is still the case that the
PDA accepts the string if and only if there is the following series of 
transitions:
\begin{align*}
 (d_0{:}{\sf dest}, \ldots, d_{n+1}{:}{\sf dest}; 
    x{:}\susp{{\sf hd}\,d_0\,d_1}, 
    y_1{:}\susp{{\sf left}\,x_1\,d_1\,d_2},
    \ldots&,
    y_n{:}\susp{{\sf right}\,x_n\,d_n\,d_{n+1}})
\\
 & \leadsto^*
   (\Psi; \Gamma, z{:}\susp{{\sf hd}\,d_0\,d_{n+1}})
\end{align*}
The difference is that the final context $\Gamma$ may hold many extra
persistent propositions than it did in the entirely-linear PDA
specification: all the original ${\sf left}\,x\,d_i\,d_{i+1}$ and
${\sf right}\,x\,d_i\,d_{i+1}$ propositions will remain in the final context
along with all the ${\sf stack}\,x\,d\,d'$ propositions that were created
during the course of evaluation.

% \begin{figure}[t]
% \fvset{fontsize=\small,boxwidth=229pt}
% \VerbatimInput{sls/pda-pers.sls}
% \caption{Linear/persistent \sls~specification of a PDA for parenthesis
%   matching.}
% \label{fig:pda-pers}
% \end{figure}

I originally conjectured that a version of Theorem~\ref{thm:destcorrect}
would hold in any specification that assigned ordered atomic propositions
to either linear or persistent propositions but that left at least
one formerly-ordered atomic proposition in the premise of every rule
as a linear atomic proposition with destinations; this would have given
a generic justification to 
turing ${\sf left}$, ${\sf right}$ and ${\sf stack}$ persistent in 
Figure~\ref{fig:pda-lin} and to turning ${\sf cont}$ persistent in
Figure~\ref{fig:dest-cbv}. However, that condition is not strong enough.
To see why, 
consider a signature with one rule, 
${\sf a} \fuse {\sf b} \fuse {\sf a} \lefti \{ {\sf b} \}$,
where ${\sf a}$ and ${\sf b}$ are ordered atomic propositions.
We can consturct the following trace:
\begin{align*}
& (x_1{:}\susp{\sf a}, x_2{:}\susp{\sf b}, x_3{:}\susp{\sf a}, 
  x_4{:}\susp{\sf b}, x_5{:}\susp{\sf a})
\leadsto 
(x{:}\susp{\sf b},
  x_4{:}\susp{\sf b}, x_5{:}\susp{\sf a})
\not\leadsto  
\intertext{From the same starting point, exactly one
other trace is possible:}
& (x_1{:}\susp{\sf a}, x_2{:}\susp{\sf b}, x_3{:}\susp{\sf a}, 
  x_4{:}\susp{\sf b}, x_5{:}\susp{\sf a})
\leadsto 
(x_1{:}\susp{\sf a}, x_2{:}\susp{\sf b}, x{:}\susp{\sf b})
\not\leadsto 
\end{align*}
However, if we perform the destination-passing transformation, letting
${\sf a}\,d\,d'$ be persistent atomic proposition and letting ${\sf
  b}\,d\,d'$ be a linear atomic proposition, then we have a series of
transitions in the transformed specification that can reuse the atomic
proposition ${\sf a}\,d_2\,d_3$ in a way that doesn't correspond to
any series of transitions in ordered logic:
\begin{align*}
&  x_1{:}\susp{{\sf a}\,d_0\,d_1}, 
   x_2{:}\susp{{\sf b}\,d_1\,d_2}, 
   x_3{:}\susp{{\sf a}\,d_2\,d_3}, 
   x_4{:}\susp{{\sf b}\,d_3\,d_4}, 
   x_5{:}\susp{{\sf a}\,d_4\,d_5}
\\ \leadsto~
&  x_1{:}\susp{{\sf a}\,d_0\,d_1}, 
   \underline{x{:}\susp{{\sf b}\,d_0\,d_3}}, 
   x_3{:}\susp{{\sf a}\,d_2\,d_3}, 
   x_4{:}\susp{{\sf b}\,d_3\,d_4}, 
   x_5{:}\susp{{\sf a}\,d_4\,d_5}
\\ \leadsto~
&  x_1{:}\susp{{\sf a}\,d_0\,d_1}, 
   x{:}\susp{{\sf b}\,d_0\,d_3}, 
   x_3{:}\susp{{\sf a}\,d_2\,d_3}, 
   \underline{x'{:}\susp{{\sf b}\,d_2\,d_5}}, 
   x_5{:}\susp{{\sf a}\,d_4\,d_5}
\end{align*}
In the
first process state, there is a path $d_0, d_1, d_2, d_3, d_4, d_5$ through
the context that reconstructs the ordering in the original ordered context.
In the second process, there is still a path $d_0, d_3, d_4, d_5$ that
allows us to reconstruct the ordered context
$(x{:}\susp{\sf b},
  x_4{:}\susp{\sf b}, x_5{:}\susp{\sf a})$ by ignoring $x_1$ and $x_3$. 
However, in the third process state above, no path exists, so the final
state cannot be reconstructed as any ordered context. 

Without identifying XXX finish

\section{Exploring the richer fragment}

foo

\subsection{Alternate semantics for parallelism and exceptions}
\label{sec:modular-parallelism}



\subsection{Futures}



\subsection{Process calculus}



\subsection{First-class continuations}





