\chapter{Destination-passing}
\label{chapter-destinations}

\section{Logical transformation: destination-adding}
\label{sec:destination-adding}

\section{Alternate semantics for parallelism and exceptions}

\section{First-class continuations}

\section{Exploring the richer fragment}

\subsection{Process calculus}

\subsection{First-class continuations}

\section{Why not just destinations?}

Seeing as the destination-passing semantics is the most general form
of substructural operational semantics presentation, and that it
subsumes both the ordered abstract machine semantics, it is worth
addressing the question: why not do {\it all} our work as a
destination-passing semantics? We could! But just as our goal in the
modular specification of programming languages is to make sure that
the semantics of call-by-need evaluation doesn't infect the
description of the semantics of

(Illustrate a hypothetical language development: natural numbers,
booleans, functions are specified with natural semantics, parallel
pairs, mutable state, and exceptions are specified with ordered
abstract machine semantics, and the pair/exception interface,
continations, and recursive suspensions are specified with
destination-passing semantics.)

